<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yangsanity&#39;s Blog</title>
  
  <subtitle>Life was like a box of chocolates</subtitle>
  <link href="http://yangsanity.me/atom.xml" rel="self"/>
  
  <link href="http://yangsanity.me/"/>
  <updated>2022-06-14T03:30:02.812Z</updated>
  <id>http://yangsanity.me/</id>
  
  <author>
    <name>jjiey</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AQS-condition</title>
    <link href="http://yangsanity.me/2022/06/13/AQS-condition/"/>
    <id>http://yangsanity.me/2022/06/13/AQS-condition/</id>
    <published>2022-06-13T13:02:19.000Z</published>
    <updated>2022-06-14T03:30:02.812Z</updated>
    
    <content type="html"><![CDATA[<p>await/signal 对标 wait/notify</p><p>condition 的 Node 会用到 CONDITION 和 CANCELLED</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;await/signal 对标 wait/notify&lt;/p&gt;
&lt;p&gt;condition 的 Node 会用到 CONDITION 和 CANCELLED&lt;/p&gt;
&lt;hr&gt;
</summary>
      
    
    
    
    <category term="source code" scheme="http://yangsanity.me/categories/source-code/"/>
    
    
    <category term="jdk source code" scheme="http://yangsanity.me/tags/jdk-source-code/"/>
    
    <category term="AQS" scheme="http://yangsanity.me/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>AQS-共享锁源码解析</title>
    <link href="http://yangsanity.me/2022/06/12/AQS-shared/"/>
    <id>http://yangsanity.me/2022/06/12/AQS-shared/</id>
    <published>2022-06-12T09:27:20.000Z</published>
    <updated>2022-06-14T03:10:08.547Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要内容为 AQS 共享锁源码的深入解析。同 <a href="/2021/08/18/AQS-exclusive/">AQS 独占锁源码的深入解析</a> 一样，在本文中暂不考虑 <em><code>Condition</code></em> 的部分（废话，共享锁也根本用不到 <code>Condition</code>），同时独占锁文章中提到的方法本文也不会再提，所以也节省了不少篇幅。</p><p>其实共享锁和独占锁的某些方法可简单对应如下：</p><table><thead><tr><th align="center">独占锁</th><th align="center">共享锁</th></tr></thead><tbody><tr><td align="center">acquire(int arg)</td><td align="center">acquireShared(int arg)</td></tr><tr><td align="center">tryAcquire(int arg)</td><td align="center">tryAcquireShared(int arg)</td></tr><tr><td align="center">acquireQueued(final Node node, int arg)</td><td align="center">doAcquireShared(int arg)</td></tr><tr><td align="center">tryAcquireNanos(int arg, long nanosTimeout)</td><td align="center">tryAcquireSharedNanos(int arg, long nanosTimeout)</td></tr><tr><td align="center">doAcquireNanos(int arg, long nanosTimeout)</td><td align="center">doAcquireSharedNanos(int arg, long nanosTimeout)</td></tr><tr><td align="center">acquireInterruptibly(int arg)</td><td align="center">acquireSharedInterruptibly(int arg)</td></tr><tr><td align="center">doAcquireInterruptibly(int arg)</td><td align="center">doAcquireSharedInterruptibly(int arg)</td></tr><tr><td align="center">release(int arg)</td><td align="center">releaseShared(int arg)</td></tr><tr><td align="center">tryRelease(int arg)</td><td align="center">tryReleaseShared(int arg)</td></tr><tr><td align="center">-</td><td align="center">doReleaseShared()</td></tr></tbody></table><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>在共享模式中，<code>nextWaiter</code> 的值永远为一个特殊值 <code>SHARED</code>。</p><p>另外在共享模式中，Node 的 <code>waitStatus</code> 会用到 0 / CANCELLED / SIGNAL / PROPAGATE 四种状态。</p><h2 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h2><p>接下来进入到本文的重点，共享锁的源码解析。</p><h3 id="acquireShared"><a href="#acquireShared" class="headerlink" title="acquireShared"></a>acquireShared</h3><p>以共享模式获取，忽略中断。通过首先至少调用一次 <code>tryAcquireShared</code> 方法来实现，成功则返回，失败则线程排队，线程可能会反复阻塞和解除阻塞，直到调用 <code>tryAcquireShared</code> 方法成功。</p><p><code>acquireShared</code> 方法执行逻辑：</p><ol><li><code>tryAcquireShared</code>：（需要子类实现）尝试以共享模式获取。获取成功则返回，失败则执行步骤 2</li><li><code>doAcquireShared</code>：以共享不间断模式获取。仔细看该方法，其实几乎就是将独占锁 <code>acquire</code> 方法执行逻辑的后三步揉在了一起：<ol><li>为获取失败的线程以共享模式（<code>Node.SHARED</code>）创建节点并入 sync queue</li><li>入队后，队列中的线程以共享不间断模式获取。这期间可能需要将某些已排队的线程挂起，直到收到信号后再次执行</li><li>获取到锁的线程如果在等待时被中断，则获取到锁后中断它（线程在排队等待时忽略中断，但是会记录是否发生过中断）</li></ol></li></ol><p><img src="/images/44-1.png" alt="acquireShared"></p><h4 id="tryAcquireShared"><a href="#tryAcquireShared" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h4><p>尝试以共享模式获取。具体逻辑需要子类去实现，默认实现抛出 <code>UnsupportedOperationException</code>。此方法由执行获取的线程调用，最终返回一个 int 值，分别代表 3 种情况：</p><ol><li>负值：获取失败</li><li>0：获取成功但后续获取失败</li><li>正值：获取成功且后续获取也可能成功</li></ol><p>因为要考虑多线程的情况，所以子类在具体实现中可能需要使用 <code>getState</code>、<code>setState</code>、<code>compareAndSetState</code> 等方法检查 和/或 修改同步状态 <code>state</code>。</p><p><img src="/images/44-2.png" alt="tryAcquireShared"></p><h4 id="doAcquireShared"><a href="#doAcquireShared" class="headerlink" title="doAcquireShared"></a>doAcquireShared</h4><p>该方法其实几乎就是将独占锁 <code>acquire</code> 方法执行逻辑的后三步揉在了一起，唯二不一样的地方是：</p><ol><li><code>addWaiter</code> 时以共享模式（<code>Node.SHARED</code>）创建节点并入 sync queue</li><li>获取锁成功后，独占模式调用的是 <code>setHead(Node node)</code> 方法，而共享模式调用的是 <code>setHeadAndPropagate(node, r)</code> 方法。该方法不止会调用 <code>setHead(Node node)</code> 方法，还会在满足某些条件的情况下继续唤醒同步队列中排队的节点。这是因为在共享模式下，锁是可以被多个线程同时获取的</li></ol><p><img src="/images/44-3.png" alt="doAcquireShared"></p><h5 id="setHeadAndPropagate"><a href="#setHeadAndPropagate" class="headerlink" title="setHeadAndPropagate"></a>setHeadAndPropagate</h5><p>从方法名就看得出来，该方法做了两件事：</p><ol><li>设置新的 head</li><li>在满足某些条件的情况下继续传播（唤醒同步队列中的后继节点）</li></ol><p><code>setHeadAndPropagate</code> 方法执行逻辑：</p><ol><li>记录老的 head</li><li>将自己设置为新 head</li><li>判断是否应该继续传播，这个 if 条件不是很好理解，一点一点看，要满足条件，则：<ol><li>propagate &gt; 0：共享锁还可以继续由其它线程获取</li><li>propagate &lt;= 0 &amp;&amp; h == null：共享锁不能再被其它线程获取，且老的头节点为 null。这里其实就不是很好理解了，有个问题：1.老的头节点什么情况下会为 null？2.老的头节点为 null 为什么还要继续去传播？</li><li>propagate &lt;= 0 &amp;&amp; h != null &amp;&amp; h.waitStatus &lt; 0：共享锁不能再被其它线程获取，且老的 head.waitStatus &lt; 0，说明老的头节点表明需要继续传播</li><li>propagate &lt;= 0 &amp;&amp; h != null &amp;&amp; h.waitStatus &gt;= 0 &amp;&amp; (h = head) == null：共享锁不能再被其它线程获取，且老的头节点表明不需要继续传播，新的头节点为 null。这个条件应该是不会成立的，因为当 head 被初始化之后，肯定不可能为 null，或许可以理解这个判断是为防止下一个条件的 NPE 常规检查吧..（如果有不同见解，欢迎指出）</li><li>propagate &lt;= 0 &amp;&amp; h != null &amp;&amp; h.waitStatus &gt;= 0 &amp;&amp; (h = head) != null &amp;&amp; h.waitStatus &lt; 0：共享锁不能再被其它线程获取，且老的头节点表明不需要继续传播，但当前调用者线程表明需要继续传播</li></ol></li><li>如果满足应该继续传播的条件，且下一个节点为 null 或在共享模式下等待，则调用 doReleaseShared 方法继续传播</li></ol><p>这里我们分析下上面对于 propagate &lt;= 0 &amp;&amp; h == null 条件提到的两个问题：<br>1.老的 head 什么情况下会为 null？</p><ol><li>假设当前同步队列为 head &lt;=&gt; node1(t1) &lt;=&gt; node2(t2)</li><li>此时有个线程调用 <code>releaseShared</code> 方法唤醒了 t1</li><li>t1 在 <code>doAcquireShared</code> 方法中执行 <code>tryAcquireShared</code> 方法获取成功，执行到 <code>setHeadAndPropagate</code> 方法中记录老的 head 并调用 <code>setHead</code> 方法将自己设置为新 head 成功后 CPU 时间片耗尽被挂起（此时同步队列为 head(node1) &lt;=&gt; node2(t2)）</li><li>此时又有个线程调用 <code>releaseShared</code> 方法唤醒了 t2（此时头节点 head(node1).waitStatus 为 0）</li><li>t2 在 <code>doAcquireShared</code> 方法中执行 <code>tryAcquireShared</code> 方法获取成功，执行到 <code>setHeadAndPropagate</code> 方法中记录老的 head 后，下面的 if 条件都不成立，返回后在 <code>doAcquireShared</code> 方法中继续执行 <code>p.next = null</code> 导致 head(node1) 完全从同步队列中断开，断开后，老的 head 和 node1 就有可能会被回收</li><li>t1 继续执行，那么此时老的 head 有可能为 null</li></ol><p>虽然这种情况很极限，但是确实有可能出现，那必然就有判空的必要，否则后边就 NPE 了</p><p>2.老的头节点为 null 为什么还要继续去传播？<br>确实继续传播下去可能会导致不必要的唤醒（唤醒后获取不到又被阻塞）。但这没关系，因为一般来说出现这种情况，必定是在多个线程在竞争调用 acquireShared 或 releaseShared 时才会如此，而在这种情况下，后续节点本身现在或很快就需要唤醒信号了。</p><p>反过来思考，万一在继续传播下去的过程中，在一个很极限的时间内满足了继续传播的条件，这样也可以加快传播，毕竟晚一点退出就多一点唤醒后面的机会。</p><p><img src="/images/44-4.png" alt="setHeadAndPropagate"></p><h6 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared"></a>doReleaseShared</h6><p>共享模式下的释放操作，目的是给后继节点发信号并确保传播。该方法其实是将传播行为做了抽象。</p><p>（关于该方法的引入及对 PROPAGATE 状态引入的思考见 <a href="/2022/06/11/AQS-PROPAGATE/">AQS-Node.PROPAGATE 状态引入的意义</a>）</p><p>有两处会调用该方法：<code>releaseShared</code>（释放共享锁）和 <code>setHeadAndPropagate</code>，所以，该方法的每一行都有可能是多条线程并发执行的！</p><p>该方法是一个死循环，唯一可以退出循环的条件是：从进入循环那一刻到退出循环的整个期间，头节点都没有改变过</p><p><code>doReleaseShared</code> 方法执行逻辑就是两个 if 条件<br>第一个 if 条件执行逻辑：</p><ol><li>h != null &amp;&amp; h != tail：如果此时 sync queue 中至少有两个节点执行步骤 2，否则去执行第二个 if 条件</li><li>如果 <code>h.waitStatus</code> 是 <code>SIGNAL</code>，将 <code>h.waitStatus</code> 由 <code>SIGNAL</code> 改为 0，然后调用 <code>unparkSuccessor</code> 方法唤醒后继节点。不要忘了该方法的每一行都有可能是多条线程并发执行的，这里用 CAS 保证了最终只会有一条线程去调用 <code>unparkSuccessor</code> 方法，其它线程又去循环了</li><li>如果 <code>h.waitStatus</code> 是 0，将 <code>h.waitStatus</code> 由 0 改为 <code>PROPAGATE</code>。这里 CAS 失败说明 <code>h.waitStatus</code> 由 0 变为了 <code>SIGNAL</code>（新节点入队）或 <code>PROPAGATE</code>（多线程竞争 CAS 导致失败）。同样不要忘了该方法的每一行都有可能是多条线程并发执行的，这里 CAS 失败的线程又去循环了<br>第二个 if 条件执行逻辑用来判断循环是否应该退出</li></ol><p><img src="/images/44-5.png" alt="doReleaseShared"></p><h3 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared"></a>releaseShared</h3><p>该方法用来在共享模式下释放锁。该方法返回值和 <code>tryReleaseShared</code> 方法的返回值一致。</p><p><code>releaseShared</code> 方法执行逻辑：</p><ol><li>调用 <code>tryReleaseShared</code> 方法尝试设置同步状态 <code>state</code>，如果 <code>tryReleaseShared</code> 返回 <code>false</code>，则 <code>releaseShared</code> 返回 <code>false</code>，否则执行步骤 2</li><li>调用 <code>doReleaseShared</code> 方法给后继节点发信号并确保传播，然后返回 <code>true</code>（<code>doReleaseShared</code> 方法上文刚分析过）</li></ol><p><img src="/images/44-6.png" alt="releaseShared"></p><h4 id="tryReleaseShared"><a href="#tryReleaseShared" class="headerlink" title="tryReleaseShared"></a>tryReleaseShared</h4><p><code>tryReleaseShared</code> 方法主要是尝试设置同步状态 <code>state</code>。具体逻辑需要子类去实现，默认实现抛出 <code>UnsupportedOperationException</code>。此方法始终由执行释放的线程调用。返回值 <code>true</code> 表示此共享模式的释放可能允许正在等待的线程获取成功（共享或独占）；否则返回 <code>false</code>。</p><p>因为要考虑多线程的情况，所以子类在具体实现中可能需要使用 <code>getState</code>、<code>setState</code>、<code>compareAndSetState</code> 等方法检查 和/或 修改同步状态 <code>state</code>。</p><p><img src="/images/44-7.png" alt="tryReleaseShared"></p><h3 id="tryAcquireSharedNanos"><a href="#tryAcquireSharedNanos" class="headerlink" title="tryAcquireSharedNanos"></a>tryAcquireSharedNanos</h3><p>大体逻辑同 <code>acquireShared</code> 方法，如注释所说，和 <code>acquireShared</code> 方法不同的是，会先检查中断状态，然后至少调用一次 <code>tryAcquireShared</code> 方法，在这其中做了超时和中断判断。获取成功则返回 <code>true</code>，超时则返回 <code>false</code>，中断则抛出 <code>InterruptedException</code>。</p><p><img src="/images/44-8.png" alt="tryAcquireSharedNanos"></p><h4 id="doAcquireSharedNanos"><a href="#doAcquireSharedNanos" class="headerlink" title="doAcquireSharedNanos"></a>doAcquireSharedNanos</h4><p>该方法相当于在 <code>doAcquireShared</code> 方法的基础上，做了超时和中断判断。注意：只有返回 <code>true</code> 时才不会调用 <code>cancelAcquire</code> 方法。</p><p>而且该方法在挂起线程之前做了个判断，当最长等待时间大于 <code>spinForTimeoutThreshold</code> 时，才会挂起。</p><p><code>spinForTimeoutThreshold</code> 字段的作用前文说过，这里再来复述一遍：该值相当于一个阈值，在一些提供等待时间的操作中会使用该值来判断，当等待时间小于该值（即超时时间非常短）时直接自旋，这样可以提高程序的响应能力。</p><p><img src="/images/44-9.png" alt="doAcquireSharedNanos"></p><h3 id="acquireSharedInterruptibly"><a href="#acquireSharedInterruptibly" class="headerlink" title="acquireSharedInterruptibly"></a>acquireSharedInterruptibly</h3><p>大体逻辑同 <code>acquireShared</code> 方法，如注释所说，和 <code>acquireShared</code> 方法不同的是，会先检查中断状态，然后至少调用一次 <code>tryAcquireShared</code> 方法，在这其中做了中断判断。中断则抛出 <code>InterruptedException</code>。</p><p><img src="/images/44-10.png" alt="acquireSharedInterruptibly"></p><h4 id="doAcquireSharedInterruptibly"><a href="#doAcquireSharedInterruptibly" class="headerlink" title="doAcquireSharedInterruptibly"></a>doAcquireSharedInterruptibly</h4><p>该方法相当于在 <code>doAcquireShared</code> 方法的基础上，做了中断判断。</p><p><img src="/images/44-11.png" alt="doAcquireSharedInterruptibly"></p><p>至此，AQS <em>共享锁</em>源码就解析完了，下篇文章会继续解析 <em>Condition</em> 部分的源码。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要内容为 AQS 共享锁源码的深入解析。同 &lt;a href=&quot;/2021/08/18/AQS-exclusive/&quot;&gt;AQS 独占锁源码的深入解析&lt;/a&gt; 一样，在本文中暂不考虑 &lt;em&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/em&gt; 的部分（废话，共享锁也根</summary>
      
    
    
    
    <category term="source code" scheme="http://yangsanity.me/categories/source-code/"/>
    
    
    <category term="jdk source code" scheme="http://yangsanity.me/tags/jdk-source-code/"/>
    
    <category term="AQS" scheme="http://yangsanity.me/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>AQS 中 Node.PROPAGATE 状态引入的意义</title>
    <link href="http://yangsanity.me/2022/06/11/AQS-PROPAGATE/"/>
    <id>http://yangsanity.me/2022/06/11/AQS-PROPAGATE/</id>
    <published>2022-06-11T02:25:32.000Z</published>
    <updated>2022-06-13T13:08:30.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于 AQS 中的 <code>Node.PROPAGATE</code> 状态，源码中是这么说的：</p><blockquote><p>PROPAGATE 状态表明下一次 acquireShared 应无条件传播。<br>releaseShared 方法应该传播到其他节点，该状态在 doReleaseShared 方法中设置（仅适用于头节点）以确保传播继续，即使其它操作已经介入。</p></blockquote><p>但光看这些晦涩的文字，还是很难很好的理解它存在的意义，为什么要引入它呢？</p><p>通过查找资料发现，其实，<code>PROPAGATE</code> 状态的引入是为了解决 AQS 的一个 bug。</p><blockquote><p>bug: <a href="https://bugs.openjdk.java.net/browse/JDK-6801020">https://bugs.openjdk.java.net/browse/JDK-6801020</a><br>fix: <a href="https://github.com/openjdk/jdk8u/commit/b63d6d68d93ebc34f8b4091a752eba86ff575fc2">https://github.com/openjdk/jdk8u/commit/b63d6d68d93ebc34f8b4091a752eba86ff575fc2</a></p></blockquote><p>这个 bug 是一个关于 <code>Semaphore</code> 的 case。</p><p>在 AQS 引入 <code>PROPAGATE</code> 状态前，并发调用 <code>Semaphore</code> 的 <code>release</code> 方法，某些情况下同步队列中排队的线程仍不会被唤醒。</p><p>这个 case 的完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSemaphore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Semaphore 初始状态为 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Semaphore SEM = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 获取 1 个许可，会阻塞等待其他线程释放许可，可被中断</span></span><br><span class="line">            SEM.acquireUninterruptibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 释放 1 个许可</span></span><br><span class="line">            SEM.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread1();</span><br><span class="line">            Thread t2 = <span class="keyword">new</span> Thread1();</span><br><span class="line">            Thread t3 = <span class="keyword">new</span> Thread2();</span><br><span class="line">            Thread t4 = <span class="keyword">new</span> Thread2();</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">            t3.start();</span><br><span class="line">            t4.start();</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">            t3.join();</span><br><span class="line">            t4.join();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引入-PROPAGATE-状态前"><a href="#引入-PROPAGATE-状态前" class="headerlink" title="引入 PROPAGATE 状态前"></a>引入 PROPAGATE 状态前</h2><p>我们来分析一下引入 <code>PROPAGATE</code> 状态前这段代码会有什么问题。</p><p>首先，我们看看当时版本的 AQS 源码是怎样的，这里我们只看和 <code>PROPAGATE</code> 状态有关的 <code>setHeadAndPropagate</code> 和 <code>releaseShared</code> 方法即可。当时还没有引入 <code>doReleaseShared</code> 方法，该方法是后来解决这个 bug 时引入的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> &amp;&amp; node.waitStatus != <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们分析下这个 bug 是如何产生的。</p><p>在 <code>TestSemaphore</code> 中，<code>Semaphore</code> 初始许可为 0，同时运行 4 个子线程，2 个子线程（t1，t2）同时获取 1 个许可，另外 2 个子线程（t3，t4）同时释放 1 个许可，每次循环主线程都会等待所有子线程运行完毕。</p><p>我们假设 t1 和 t2 先获取许可，因为初始许可为 0，所以 t1 和 t2 入同步队列，假设此刻的同步队列是这样的：</p><blockquote><p>head &lt;=&gt; node1(t1) &lt;=&gt; node2(t2 tail)</p></blockquote><p>此时 <code>head.waitStatus</code> 为 <code>SIGNAL</code>。接下来，t3 先释放，t4 后释放：</p><ol><li>t3 调用 <code>tryReleaseShared</code> 方法释放 1 个许可，然后调用 <code>unparkSuccessor</code> 方法将 <code>head.waitStatus</code> 由 <code>SIGNAL</code> 改为 0，并唤醒后继节点 t1 后退出</li><li>t1 被 t3 唤醒，调用 <code>tryAcquireShared</code> 方法获取到许可并返回 0（此时还未调用 <code>setHeadAndPropagate</code> 方法中的 <code>setHead</code> 方法将自己设置为新 head）</li><li>t4 调用 <code>tryReleaseShared</code> 方法释放 1 个许可，因为 head 未改变，因此 <code>head.waitStatus</code> 仍为 0，这导致 t4 退出，不会继续调用 <code>unparkSuccessor</code> 方法唤醒后继节点 t2</li><li>t1 继续调用 <code>setHeadAndPropagate</code> 方法，首先将自己设置为新 head，然后因为 <code>tryAcquireShared</code> 方法返回 0 导致 t1 退出，不会继续调用 <code>unparkSuccessor</code> 方法唤醒后继节点 t2</li></ol><p>至此，t2 永远不会被唤醒，问题产生。</p><h2 id="引入-PROPAGATE-状态后"><a href="#引入-PROPAGATE-状态后" class="headerlink" title="引入 PROPAGATE 状态后"></a>引入 PROPAGATE 状态后</h2><p>接下来我们再来看看引入 <code>PROPAGATE</code> 状态后这个问题如何解决。</p><p>同样先看下引入 <code>PROPAGATE</code> 状态后的 AQS 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head;</span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的例子：</p><ol><li>t3 调用 <code>tryReleaseShared</code> 方法释放 1 个许可，然后调用 <code>doReleaseShared</code> 方法将 <code>head.waitStatus</code> 由 <code>SIGNAL</code> 改为 0，并唤醒后继节点 t1 后退出</li><li>t1 被 t3 唤醒，调用 <code>tryAcquireShared</code> 方法获取到许可并返回 0（此时还未调用 <code>setHeadAndPropagate</code> 方法中的 <code>setHead</code> 方法将自己设置为新 head）</li><li>t4 调用 <code>tryReleaseShared</code> 方法释放 1 个许可，因为 head 未改变，因此 <code>head.waitStatus</code> 仍为 0，然后调用 <code>doReleaseShared</code> 方法将 <code>head.waitStatus</code> 由 0 改为 <code>PROPAGATE</code> 后 t4 退出</li><li>t1 继续调用 <code>setHeadAndPropagate</code> 方法，首先将自己设置为新 head，因为此时旧 <code>head.waitStatus</code> 为 <code>PROPAGATE</code> 且同步队列中 t1 还有后继节点 t2，所以继续调用 <code>doReleaseShared</code> 方法，将 <code>head.waitStatus</code> 由 <code>SIGNAL</code> 改为 0，并唤醒后继节点 t2 后退出</li></ol><p>后继节点 t2 被唤醒，问题解决。</p><h2 id="个人见解与思考"><a href="#个人见解与思考" class="headerlink" title="个人见解与思考"></a>个人见解与思考</h2><p>其实，<code>setHeadAndPropagate</code> 方法逻辑改成如下也可以解决这个 bug，甚至都不需要引入 <code>PROPAGATE</code> 状态。</p><p>（基本思路是：<code>head.waitStatus</code> 为 0 是多线程下可能出现的中间状态，既然 <code>head.waitStatus</code> 在多线程下遇 0 要变 <code>PROPAGATE</code>，那在 <code>setHeadAndPropagate</code> 方法中判断头节点时加上 0 就行了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || node.waitStatus &lt;= <span class="number">0</span>) &#123; <span class="comment">// 修改这里</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，这就产生了一个新问题：引入 <code>PROPAGATE</code> 状态可以解决这个 bug，但是解决这个 bug 并不一定非要引入 <code>PROPAGATE</code> 状态，那为什么最终还是引入了呢？</p><p>查了一些资料后也无果，下面有一些自己的思考，欢迎交流指正。</p><h3 id="解决-bug"><a href="#解决-bug" class="headerlink" title="解决 bug"></a>解决 bug</h3><p>引入 <code>PROPAGATE</code> 状态的第一个好处：解决这个 bug。</p><p>这个 bug 产生的原因，就是因为共享锁的获取和释放在同一时刻很可能会有多条线程并发执行，这就导致在这个过程中可能会产生这种 <code>waitStatus</code> 为 0 的中间状态，可以通过引入 <code>PROPAGATE</code> 状态来解决这个问题。</p><h3 id="语意更清晰"><a href="#语意更清晰" class="headerlink" title="语意更清晰"></a>语意更清晰</h3><p>引入 <code>PROPAGATE</code> 状态的第二个好处：语意更清晰。</p><p>我们可以再深入思考下，既然 <code>head.waitStatus</code> 由 0 变 <code>PROPAGATE</code>，那 <code>head.waitStatus</code> 什么时候是 0？</p><p>因为 <code>doReleaseShared</code> 方法只有 <code>releaseShared</code> 和 <code>setHeadAndPropagate</code> 方法调用，所以从排列组合来说，无非是以下四种情况：<br>假设有两个线程（或多个线程）</p><ol><li>两个同时调用 <code>releaseShared</code>，一个先将 <code>head.waitStatus</code> 由 <code>SIGNAL</code> 改为 0</li><li>两个同时调用 <code>setHeadAndPropagate</code>，一个先将 <code>head.waitStatus</code> 由 <code>SIGNAL</code> 改为 0</li><li>一个先调 <code>releaseShared</code> 将 <code>head.waitStatus</code> 由 <code>SIGNAL</code> 改为 0，另一个再调 <code>setHeadAndPropagate</code></li><li>一个先调 <code>setHeadAndPropagate</code> 将 <code>head.waitStatus</code> 由 <code>SIGNAL</code> 改为 0，另一个再调 <code>releaseShared</code></li></ol><p>下面具体看下每种情况：（node1(t1 0) 表示 node1.thread 为 t1，node1.waitStatus 为 0）</p><p>情况 1：</p><blockquote><p>head(-1) &lt;=&gt; node1(t1 0)</p></blockquote><ol><li>线程 A 调用 <code>releaseShared</code> 方法将 <code>head.waitStatus</code> 由 <code>SIGNAL</code> 改为 0 并唤醒 t1 后退出。此时 head(0) &lt;=&gt; node1(t1 0)</li><li>线程 B 调用 <code>releaseShared</code> 方法时发现 <code>head.waitStatus</code> 为 0</li></ol><p>情况 2：</p><blockquote><p>head(-1) &lt;=&gt; node1(t1 -1) &lt;=&gt; node2(t2 -1) &lt;=&gt; node3(t3 0)</p></blockquote><ol><li>线程 A 调用 <code>releaseShared</code> 方法将 <code>head.waitStatus</code> 由 <code>SIGNAL</code> 改为 0 并唤醒 t1 后退出。此时 head(0) &lt;=&gt; node1(t1 -1) &lt;=&gt; node2(t2 -1) &lt;=&gt; node3(t3 0)</li><li>t1 获取到锁成为头节点，此时 <code>head.waitStatus</code> 为 <code>SIGNAL</code>，调用 <code>doReleaseShared</code> 方法。此时 head(node1 -1) &lt;=&gt; node2(t2 -1) &lt;=&gt; node3(t3 0)</li><li>线程 B 调用 <code>releaseShared</code> 方法将 <code>head.waitStatus</code> 由 <code>SIGNAL</code> 改为 0 并唤醒 t2 后退出。此时 head(node1 0) &lt;=&gt; node2(t2 -1) &lt;=&gt; node3(t3 0)</li><li>t2 获取到锁成为头节点，此时 <code>head.waitStatus</code> 为 <code>SIGNAL</code>，调用 <code>doReleaseShared</code> 方法。此时 head(node2 -1) &lt;=&gt; node3(t3 0)</li><li>t1 将 <code>head.waitStatus</code> 由 <code>SIGNAL</code> 改为 0 并去唤醒 t3。此时 head(node2 0) -&gt; node3(t3 0)</li><li>t2 发现 <code>head.waitStatus</code> 为 0</li></ol><p>情况 3：</p><blockquote><p>head(-1) &lt;=&gt; node1(t1 -1) &lt;=&gt; node2(t2 0)</p></blockquote><ol><li>线程 A 调用 <code>releaseShared</code> 方法将 <code>head.waitStatus</code> 由 <code>SIGNAL</code> 改为 0 并唤醒 t1 后退出。此时 head(0) &lt;=&gt; node1(t1 -1) &lt;=&gt; node2(t2 0)</li><li>t1 获取到锁成为头节点，此时 <code>head.waitStatus</code> 为 <code>SIGNAL</code>，调用 <code>doReleaseShared</code> 方法。此时 head(node1 -1) &lt;=&gt; node2(t2 0)</li><li>线程 B 调用 <code>releaseShared</code> 方法将 <code>head.waitStatus</code> 由 <code>SIGNAL</code> 改为 0 并去唤醒 t2 后退出。此时 head(node1 0) &lt;=&gt; node2(t2 0)</li><li>t1 发现 <code>head.waitStatus</code> 为 0</li></ol><p>情况 4：</p><blockquote><p>head(-1) &lt;=&gt; node1(t1 -1) &lt;=&gt; node2(t2 0)</p></blockquote><ol><li>线程 A 调用 <code>releaseShared</code> 方法将 <code>head.waitStatus</code> 由 <code>SIGNAL</code> 改为 0 并唤醒 t1 后退出。此时 head(0) &lt;=&gt; node1(t1 -1) &lt;=&gt; node2(t2 0)</li><li>t1 获取到锁成为头节点，此时 <code>head.waitStatus</code> 为 <code>SIGNAL</code>，调用 <code>doReleaseShared</code> 方法。此时 head(node1 -1) &lt;=&gt; node2(t2 0)</li><li>t1 将 <code>head.waitStatus</code> 由 <code>SIGNAL</code> 改为 0 并唤醒 t2 后退出。此时 head(node1 0) &lt;=&gt; node2(t2 0)</li><li>线程 B 调用 <code>releaseShared</code> 方法，发现 <code>head.waitStatus</code> 为 0</li></ol><p>我们知道，<code>head.waitStatus</code> 为 0 代表 head 是刚成为头节点的，即 head 刚初始化，或 tail 获取到锁后成为新 head，导致队列中只剩下 head（在这个前提下，后续节点可能正在加入，也可能刚加入还没来得及将 <code>head.waitStatus</code> 改为 <code>SIGNAL</code>，但这不重要）。</p><p>从上述情况中可以发现：<code>head.waitStatus</code> 为 0 还可以短暂代表共享模式下有线程正在调用 <code>unparkSuccessor</code> 方法去唤醒后继节点（其实就是这种情况被标识为了 <code>PROPAGATE</code>）。</p><p>所以，引入 <code>PROPAGATE</code> 状态后，<code>head.waitStatus</code> 为 0 和 <code>PROPAGATE</code> 就分别代表不同的情况，否则就要揉在一起，不好理解。</p><h3 id="加速传播"><a href="#加速传播" class="headerlink" title="加速传播"></a>加速传播</h3><p>引入 <code>PROPAGATE</code> 状态的第三个好处：加速唤醒后继节点</p><p><code>doReleaseShared</code> 方法中有这个条件判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">    <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>如果没有 <code>PROPAGATE</code> 状态，当多条线程同时运行到这里后，可能就直接退出了，虽然这时有个线程正在调用 <code>unparkSuccessor</code> 方法去唤醒后继节点，但唤醒后的线程也需要等到获取到锁且成为头节点后才能调用 <code>doReleaseShared</code> 方法再去唤醒后继节点。</p><p>当并发大时，在这个过程中很有可能会有新节点入队并满足唤醒条件，所以有了 <code>PROPAGATE</code> 状态，当多条线程同时运行到这里后，CAS 失败后的线程可以再次去循环判断能否唤醒后继节点，如果满足唤醒条件就去唤醒。</p><p>毕竟，调用 <code>doReleaseShared</code> 方法越多、越早就越有可能更快的唤醒后继节点。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因此，bug 解决的更优雅且可以带来不错的收益也许才是最终引入 <code>PROPAGATE</code> 状态的原因吧，欢迎交流指正。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;关于 AQS 中的 &lt;code&gt;Node.PROPAGATE&lt;/code&gt; 状态，源码中是这么说的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p</summary>
      
    
    
    
    <category term="source code" scheme="http://yangsanity.me/categories/source-code/"/>
    
    
    <category term="jdk source code" scheme="http://yangsanity.me/tags/jdk-source-code/"/>
    
    <category term="AQS" scheme="http://yangsanity.me/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>AQS-独占锁源码解析</title>
    <link href="http://yangsanity.me/2021/08/18/AQS-exclusive/"/>
    <id>http://yangsanity.me/2021/08/18/AQS-exclusive/</id>
    <published>2021-08-18T01:23:07.000Z</published>
    <updated>2022-05-07T02:09:59.752Z</updated>
    
    <content type="html"><![CDATA[<p>要深入理解 AQS 的源码确实不容易，因为其中有很多情况要考虑，甚至源码中的每一个 if 语句可能就包含着一种或几种情况，尤其是在共享锁部分；另外还有一些因素也要考虑，比如多线程调用、CPU 分配的时间片、虚假唤醒等。</p><p>本文主要内容为 AQS 独占锁源码的深入解析，所以在本文中暂不考虑<em>共享锁</em>和 <em><code>Condition</code></em> 的部分。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>AQS 全称为 <code>AbstractQueuedSynchronizer</code>，位于 <code>java.util.concurrent.locks</code> 包下，继承 <code>AbstractOwnableSynchronizer</code>，是一个抽象类。</p><p>AQS 提供了一个框架，用于实现依赖先进先出（FIFO）等待队列的阻塞锁和相关同步器（信号量、事件等），是大多数依赖单个原子 int 值来表示状态的同步器的基础。这个单个原子 int 值在源码中是一个名为 <code>state</code> 的字段，由 volatile 修饰，子类必须重写更改此状态值的 protected 方法，并定义该状态在获取或释放此对象的含义。也因此，AQS 中的其他方法会执行所有排队和阻塞机制。</p><p>另外因为要考虑到多线程的因素，所以只有使用 <code>getState</code>、<code>setState</code> 和 <code>compareAndSetState</code> 方法操作的状态值才会在同步方面进行跟踪。换言之，子类重写的 protected 方法的具体实现中需要使用这些方法来检查 和/或 修改状态值。</p><p>在使用上，子类应将其定义为非 public 的内部帮助类，用于实现其封闭类的同步属性，然后具体的使用都委托给该帮助类来实现。</p><p>AQS 支持独占模式和共享模式，默认为独占模式，子类可以根据需求来选择实现两种模式之一或两者。具体来说，只需根据适用情况重写以下方法即可（默认实现都会抛出 <code>UnsupportedOperationException</code>）：</p><ul><li><code>tryAcquire</code>（独占模式获取）</li><li><code>tryRelease</code>（独占模式释放）</li><li><code>tryAcquireShared</code>（共享模式获取）</li><li><code>tryReleaseShared</code>（共享模式释放）</li><li><code>isHeldExclusively</code>（供 <code>ConditionObject</code> 方法内部调用）</li></ul><p>以上方法的实现必须是内部线程安全的，并且应该是简短不阻塞的。</p><p>在不同模式下等待的线程共享同一个 FIFO 队列，称为同步队列（sync queue）。</p><p>AQS 中还定义了一个 <code>ConditionObject</code> 类，它可以被支持独占模式的子类用作 <code>Condition</code> 实现。AQS 不提供创建 <code>Condition</code> 的方法，<code>ConditionObject</code> 的行为取决于其同步器实现的语义。</p><p>AQS 类的序列化仅存储底层原子整数维护的状态，因此反序列化的对象将具有空的线程队列。需要序列化的子类需要定义 <code>readObject</code> 方法，该方法在反序列化时会将其恢复到已知的初始状态。</p><p>也可以提供公平的 FIFO 获取顺序，实现为：当 <code>hasQueuedPredecessors</code> 方法返回 true 时，定义 <code>tryAcquire</code> 方法返回 <code>false</code>。</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h3 id="Exclusive-Mode"><a href="#Exclusive-Mode" class="headerlink" title="Exclusive Mode"></a>Exclusive Mode</h3><p>独占模式需要实现 <code>tryAcquire</code>、<code>tryRelease</code> 以及 <code>isHeldExclusively</code>（根据需要）方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不可重入互斥锁，0 表示 unlocked 状态，使用 1 表示 locked 状态。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 内部帮助类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否处于 locked 状态</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 state 为 0，则获取锁</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 不可重入互斥锁 acquires 始终为 1</span></span><br><span class="line">            <span class="keyword">assert</span> acquires == <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过将 state 设置为 0 来释放锁</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 不可重入互斥锁 releases 始终为 1</span></span><br><span class="line">            <span class="keyword">assert</span> releases == <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提供一个 Condition</span></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正确反序列化</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">            s.defaultReadObject();</span><br><span class="line">            <span class="comment">// 重置为 unlocked 状态</span></span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sync 对象完成了所有的困难工作，我们直接使用它即可</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Shared-Mode"><a href="#Shared-Mode" class="headerlink" title="Shared Mode"></a>Shared Mode</h3><p>共享模式需要实现 <code>tryAcquireShared</code> 和 <code>tryReleaseShared</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedModeDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类似于 CountDownLatch 的 latch 类，但是它只需要一个 signal 即可触发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BooleanLatch</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 内部帮助类</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">boolean</span> <span class="title">isSignalled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> isSignalled() ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">                setState(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sync 对象完成了所有的困难工作，我们直接使用它即可</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSignalled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sync.isSignalled();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * test BooleanLatch</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BooleanLatch latch = <span class="keyword">new</span> BooleanLatch();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;] sleep 5s&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;] sleep end, signal thread [main]&quot;</span>);</span><br><span class="line">            latch.signal();</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;thread [main] await&quot;</span>);</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;thread [main] end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AbstractOwnableSynchronizer"><a href="#AbstractOwnableSynchronizer" class="headerlink" title="AbstractOwnableSynchronizer"></a>AbstractOwnableSynchronizer</h2><p><code>AbstractOwnableSynchronizer</code> 是 AQS 继承的类，用来记录跟踪拥有独占同步器的线程，为创建需要所有权概念的锁和相关同步器提供基础。该类的子类或一些工具可以通过维护 <code>exclusiveOwnerThread</code> 字段值来帮助用户控制和监控访问并提供诊断。</p><p>该类中只有一个字段 <code>exclusiveOwnerThread</code>，从字段名中可以看到，该字段可以记录持有独占锁的线程；此外，还提供了该字段的 set 和 get 方法。</p><p><img src="/images/43-1.png" alt="AbstractOwnableSynchronizer"></p><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>Node 是等待队列（wait queue）的节点类，等待队列包括同步队列（sync queue）和条件队列（condition queue）。</p><p>等待队列是 “CLH” 锁队列的变体（之前详细介绍过 “CLH” 锁，see <a href="/2021/08/10/CLHLock/">AQS 基础–多图详解 CLH 锁的原理与实现</a>），“CLH” 锁通常用于自旋锁，在 AQS 中将它们用作阻塞同步器，但使用相同的基本策略：在其节点的前驱中保存有关线程的一些控制信息。</p><p>每个节点中的 <code>waitStatus</code> 字段可以表示线程是否应该阻塞。节点在其前驱 release 时会收到信号。队列中的每个节点都充当一个特定的通知监视器，持有一个等待线程。如果线程是队列中的第一个，则可以尝试去获取锁，但并不保证获取成功，这只是给予它竞争的权利而已，因此当前已释放的竞争者线程可能也需要继续重新等待。</p><p>在该类中，prev 属性在原始 “CLH” 锁中其实并没有用到，在这里主要是用于处理状态为 CANCELLED 的节点；而 next 属性则用来实现阻塞机制，换句话说，next 指针其实是一种优化，通常不需要向后扫描（具体表现在 <code>unparkSuccessor</code> 方法中，先看 next 是否符合条件，不符合再遍历，大多数情况下可能都会符合）。</p><p>“CLH” 队列需要一个虚拟头节点来开始。但是我们不在构建时就创建它，因为如果不存在竞争，这就是在做无用功。相反，在第一次竞争时构造节点并设置头尾指针（延迟初始化）。</p><p>在 <code>Conditions</code> 中等待的线程使用相同的节点，但使用额外的链接。<code>Conditions</code> 链接队列中的节点仅在独占持有时才会被访问，所以不需要考虑并发情况。在 <code>await</code> 时，一个节点被插入到 condition queue 中；<code>signal</code> 时，节点被转移到 sync queue。</p><p>Node 中的 <code>nextWaiter</code> 字段可以表明当前节点正在独占模式还是共享模式下等待。</p><p>Node 节点有以下等待状态（waitStatus）：</p><table><thead><tr><th align="center">等待状态</th><th align="center">值</th><th align="center">描述</th><th align="center">具体描述</th></tr></thead><tbody><tr><td align="center">-</td><td align="center">0</td><td align="center">初始值</td><td align="center">-</td></tr><tr><td align="center">CANCELLED</td><td align="center">1</td><td align="center">表明线程已取消</td><td align="center">由于超时或中断，该节点被取消，此后节点永远不会离开这个状态，而且取消节点的线程永远不会再次阻塞</td></tr><tr><td align="center">SIGNAL</td><td align="center">-1</td><td align="center">表明后继线程需要唤醒</td><td align="center">该节点的后继节点被（或即将被）阻塞（<code>LockSupport.park</code> 方法），因此当前节点在释放（<code>release</code> 方法）或取消（<code>cancelAcquire</code> 方法）时必须唤醒（<code>unparkSuccessor</code> 方法）其后继节点。为了避免竞争，acquire 方法中必须首先表明它们需要一个信号（<code>shouldParkAfterFailedAcquire</code> 方法），然后重试原子获取，然后在获取失败时阻塞</td></tr><tr><td align="center">CONDITION</td><td align="center">-2</td><td align="center">表明线程在 condition queue 中等待</td><td align="center">该节点当前在 condition queue 中，直到转移后，它才会用作 sync queue 的节点，此时状态将设置为 0（此处使用此值与该字段的其他用途无关，但可以简化机制）</td></tr><tr><td align="center">PROPAGATE</td><td align="center">-3</td><td align="center">表明下一次 <code>acquireShared</code> 应无条件传播</td><td align="center"><code>releaseShared</code> 方法应该传播到其他节点，该状态在 <code>doReleaseShared</code> 方法中设置（仅适用于头节点）以确保传播继续，即使其它操作已经介入</td></tr></tbody></table><p>Node 类源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表明节点在共享模式下等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 表明节点在独占模式下等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表明线程已取消的 waitStatus 值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 表明后继线程需要唤醒的 waitStatus 值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 表明线程在 condition 中等待的 waitStatus 值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 表明下一次 acquireShared 应无条件传播的 waitStatus 值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态字段，仅采用以下值：SIGNAL / CANCELLED / CONDITION / PROPAGATE / 0</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点的前驱节点，入队时分配，仅在出队时为空（for GC）</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点的后继节点，入队时分配，绕过取消的前驱节点时进行调整，并在出队时为空（for GC）</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该节点封装的线程。在构造时初始化并在使用后置为 null。</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享模式：特殊值 SHARED</span></span><br><span class="line">    <span class="comment">// 独占模式：null 或 下一个在 condition queue 中等待的节点（如果用到 Condition）</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果节点在共享模式下等待，则返回 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前节点的前驱节点，如果为 null 则抛出 NullPointerException，当前驱节点不为空时使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于建立 dummyHead 或 SHARED 标记</span></span><br><span class="line">    Node() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// addWaiter 方法中使用</span></span><br><span class="line">    Node(Thread thread, Node mode) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Condition 中使用（准确的说是在 ConditionObject#addConditionWaiter 方法中使用）</span></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123;</span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在独占模式中，<code>nextWaiter</code> 的值为 <code>null</code> 或下一个在 condition queue 中等待的节点（如果有 condition queue 的话。因本文暂不分析其源码，所以在本文中可以认为该值就是 <code>null</code>）。</p><p>另外在独占模式中，Node 的 <code>waitStatus</code> 只会用到 0 / CANCELLED / SIGNAL 这三种状态。</p><h2 id="Sync-Queue"><a href="#Sync-Queue" class="headerlink" title="Sync Queue"></a>Sync Queue</h2><p>sync queue 是同步队列，代表<strong>所有等待获取锁的线程集合</strong>，是个有虚拟头节点（延迟初始化，下文中称其为 dummyHead）的双向链表。<code>head</code> 指向头节点（即 dummyHead），<code>tail</code> 指向尾节点，<code>prev</code> 指向上一个节点，<code>next</code> 指向下一个节点。</p><p><img src="/images/43-2.png" alt="sync-queue"></p><p>对于 <code>head</code> 中 thread 属性可以有另一种理解：sync queue 中的每个节点内部都会封装一个线程，唯独 <code>head</code> 节点中的为 <code>null</code>，其实换个角度，也可以认为 <code>head</code> 节点中也封装了线程，只不过此时该线程获取到了锁，正在执行逻辑。</p><h2 id="Fields"><a href="#Fields" class="headerlink" title="Fields"></a>Fields</h2><p>4 个重要的字段属性：<code>head</code> / <code>tail</code> / <code>state</code> / <code>spinForTimeoutThreshold</code><br>5 个用于支持 CAS 算法的 Unsafe 类操作的字段：<code>state</code> / <code>head</code> / <code>tail</code> / <code>waitStatus</code> / <code>next</code>（略）</p><p><img src="/images/43-3.png" alt="fields-1"></p><p><code>spinForTimeoutThreshold</code> 字段相当于一个阈值，在一些提供等待时间的方法中会使用该值来判断，当等待时间小于该值（即超时时间非常短）时直接自旋，这样可以提高程序的响应能力。</p><p><img src="/images/43-4.png" alt="spinForTimeoutThreshold"></p><h2 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h2><p>了解了前文的前置知识，接下来终于要进入到本文的重点，独占锁的源码解析。</p><h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><p>以独占模式获取，忽略中断。通过至少调用一次 <code>tryAcquire</code> 方法来实现，成功则返回，失败则线程排队。线程可能会反复阻塞和解除阻塞，直到调用 <code>tryAcquire</code> 方法获取成功。</p><p><code>acquire</code> 方法执行逻辑：</p><ol><li><code>tryAcquire</code>：（需要子类实现）尝试以独占模式获取，获取成功则返回，失败则执行步骤 2</li><li><code>addWaiter</code>：为获取失败的线程以独占模式（<code>Node.EXCLUSIVE</code>）创建节点并入 sync queue，执行步骤 3</li><li><code>acquireQueued</code>：入队后，队列中的线程以独占不间断模式获取。这期间可能需要将某些已排队的线程挂起，直到收到信号后再次执行</li><li><code>selfInterrupt</code>：获取到锁的线程如果在等待时被中断，在这里中断它（线程在排队等待时忽略中断，但是会记录是否发生过中断）</li></ol><p><img src="/images/43-5.png" alt="acquire"></p><h4 id="Diagram-of-acquire"><a href="#Diagram-of-acquire" class="headerlink" title="Diagram of acquire"></a>Diagram of acquire</h4><p>在详细解析 <code>acquire</code> 源码之前，先在上帝视角给大家提供一张该方法的执行流程图，方便对执行过程有个详细了解，也方便在下面的源码解析过程中，看到某个方法时，知道程序当前处于什么地方，不至于在复杂的源码中迷失。</p><p><img src="/images/43-6.png" alt="diagram-of-acquire"></p><h4 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h4><p>尝试以独占模式获取。具体逻辑需要子类去实现，默认实现抛出 <code>UnsupportedOperationException</code>。此方法由执行 <code>acquire</code> 的线程调用，返回值代表获取成功（<code>return true</code>）或失败（<code>return false</code>）。</p><p>因为要考虑多线程的情况，所以子类在具体实现中可能需要使用 <code>getState</code>、<code>setState</code>、<code>compareAndSetState</code> 等方法检查 和/或 修改同步状态 <code>state</code>。</p><p><img src="/images/43-7.png" alt="tryAcquire"></p><h4 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h4><p>为当前线程以给定模式（<code>Node.EXCLUSIVE</code> 或 <code>Node.SHARED</code>）创建节点并入 sync queue，返回新入队的节点。</p><p>该方法的操作就是正常的节点入队操作，具体逻辑没什么好说的，有几个注意的点：</p><ol><li>如果队列为空，会先创建一个虚拟头节点，再将当前线程节点插入队尾，即采用前文中提到的延迟初始化 <code>head</code></li><li>新节点入 sync queue 操作：先设置 <code>node.prev = tail</code>，再 CAS 设置 <code>tail = node</code>，最后设置 <code>tail.next = node</code>（注意<strong>这几步不是一个原子操作</strong>）</li></ol><p>此外，我们可以从该方法的实现中学到一个重要思想：fast path，即先简单尝试一下，成功就返回，失败再自旋循环。因为其实很多时候，直接操作就能解决大部分问题。</p><p><img src="/images/43-8.png" alt="addWaiter"></p><p>注意，在入队操作过程中，当某线程创建了新节点后，执行 <code>compareAndSetTail(pred, node)</code> 成功，但是 <code>pred.next = node</code> 还没有开始执行时（或刚好执行到此 CPU 给该线程分配的时间片耗尽），可能会出现下面这种现象：</p><p><img src="/images/43-9.png" alt="traverse-from-tail"></p><p>在高并发的场景下，甚至可能会出现下面这种现象：</p><p><img src="/images/43-10.png" alt="traverse-from-tail-2"></p><p>此时，如果从 <code>head</code> 往后遍历队列，会出现一个严重的问题：遍历不到新入队的节点！而从 <code>tail</code> 往前遍历是没有这个问题的。究其原因，就是因为新节点入队操作并不是一个原子操作。这也是 AQS 中遍历队列都采用从 <code>tail</code> 往前遍历的原因。</p><h5 id="enq"><a href="#enq" class="headerlink" title="enq"></a>enq</h5><p>普通的节点入队操作，主要用到 <strong><em>CAS + 自旋</em></strong>，如果队列为空，会先创建一个虚拟头节点。最终返回新入队节点的前驱节点。</p><p><img src="/images/43-11.png" alt="enq"></p><h4 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h4><p>该方法情况比较复杂，需要详细分析（这里再贴一下前文的执行流程图）。</p><p><img src="/images/43-6.png" alt="diagram-of-acquire"></p><p><code>acquireQueued</code> 方法执行逻辑：</p><ol><li>如果当前线程是排队的第一个线程，执行 <code>tryAcquire</code> 方法尝试以独占模式获取</li><li>如果获取成功，重新设置队列头节点 （<code>setHead</code>） 后退出</li><li>如果当前线程不是排队的第一个线程 或 当前线程是排队的第一个线程但获取失败，将前驱节点状态置为 SIGNAL （<code>shouldParkAfterFailedAcquire</code>）</li><li>设置成功后，挂起线程，等待唤醒 （<code>parkAndCheckInterrupt</code>）</li><li>线程被唤醒后回到步骤 1 重复上述步骤，直到获取成功</li><li>如果上述步骤执行过程中出现异常导致获取失败，取消正在进行的获取尝试（<code>cancelAcquire</code>）</li></ol><p>还有几点需要注意：</p><ol><li><code>interrupted</code> 字段用来记录线程在等待过程中是否发生过中断，该字段也是此方法的最终返回值</li><li>线程在排队等待时是忽略中断的，无论线程在等待过程中是否发生过中断，都需要获取到锁后才能返回。返回后再根据 <code>interrupted</code> 字段的值来决定是否中断</li></ol><p><img src="/images/43-12.png" alt="acquireQueued"></p><h5 id="setHead"><a href="#setHead" class="headerlink" title="setHead"></a>setHead</h5><p>将 <code>head</code> 指向当前节点，内部属性 <code>thread</code> 和 <code>prev</code> 置为 <code>null</code>。</p><p>其实该方法就是相当于，获取成功后，把该节点置为新的 dummyHead。但注意，此时旧的 dummyHead 还存在，且 oldDummyHead.next = newDummyHead，<code>setHead</code> 执行结束后才会清除旧的 dummyHead，将 oldDummyHead.next 指向 <code>null</code>（这一步在 <code>acquireQueued</code> 中 <code>p.next = null</code>）。</p><p><img src="/images/43-13.png" alt="setHead"></p><p>思考一下，这里设置头节点为什么不用 <code>compareAndSetHead</code>，而是直接 <code>head = node</code>？</p><p>因为这是在独占锁情况下，获取到锁的线程只会有一个，因此该方法不会存在并发调用的情况，可以放心大胆的使用 <code>head = node</code>。</p><h5 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h5><p>该方法逻辑不难理解，方法名也已说明了用意：should park after failed acquire（获取失败后应该挂起吗？）</p><p>而该方法唯一 <code>return true</code> 的条件就是 <code>pred.waitStatus = Node.SIGNAL</code>，其它时候都会返回 <code>false</code>。这也说明，获取失败后应该挂起线程的条件是：该节点的前置节点状态为 SIGNAL。否则，我们应该把前置节点的状态设置为 SIGNAL。（这里就同前文提到的 “CLH” 锁呼应上了，即在其节点的前驱中保存有关线程的一些控制信息）</p><p><img src="/images/43-14.png" alt="shouldParkAfterFailedAcquire"></p><p><strong>特别注意：</strong>当最终结果返回时，程序此时还处于 <code>acquireQueued</code> 方法的 <code>for (;;)</code> 中。因此，当最终结果返回 <code>false</code> 时，程序会再次回到上述 <code>acquireQueued</code> 方法执行逻辑的步骤 1 去执行。或者这里也可以理解为一个优化，相当于变相又给了线程一个去尝试获取的机会，也许这次就成功了。</p><h5 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h5><p>node 的前置节点状态设置为 SIGNAL 了，挂起线程，直到收到释放信号或中断唤醒它。</p><p><strong>特别注意：</strong>假如此刻它被唤醒，它需要接着去执行。别忘了，程序此时还处于 <code>acquireQueued</code> 方法的 <code>for (;;)</code> 中，所以程序会再次回到上述 <code>acquireQueued</code> 方法执行逻辑的步骤 1 去执行，直到它获取成功。</p><p><img src="/images/43-15.png" alt="parkAndCheckInterrupt"></p><p>思考这个问题：该方法最终返回值是线程是否中断，为什么不用 <code>Thread.currentThread().isInterrupted()</code> 方法？</p><p>在 <a href="/2021/07/20/Thread/#isInterrupted">Thread 源码解析</a> 中说过，这两个方法的区别是：<code>Thread.interrupted()</code> 方法除了会返回线程是否中断外，还会重置线程的中断状态。那么就有个新问题：返回值是线程是否中断，我只需要知道是否中断就行了，为什么还要清除中断状态？</p><p>这是因为，中断后，如果不清除中断状态，下次 park 是不生效的。假如该线程下次仍然没有获取到锁，就 park 不住了（关于这个结论，做个实验就知道了。如果不想做实验，我也帮你做了，see <a href="/2021/08/12/InterruptPark/">The relationship between Interrupt and Park</a>）。因此这里需要一个又能重置线程中断状态又能返回线程是否中断的方法，所以必须使用 <code>Thread.interrupted()</code> 方法。</p><h5 id="cancelAcquire"><a href="#cancelAcquire" class="headerlink" title="cancelAcquire"></a>cancelAcquire</h5><p>如果在获取过程中出现异常导致获取失败，取消正在进行的获取尝试。</p><p>如何取消呢？是不是就是将此节点从队列中彻底删除？</p><p>其实不是的，该方法对应的情况比较多，基本上最终就是修改了节点的 <code>waitStatus</code> 以及 <code>next</code> 指针，将节点彻底从队列中删除是依赖后续的遍历 / <code>setHead</code> / <code>p.next = null</code> 操作。具体可见上篇文章 <a href="/2021/08/16/AQS-cancelAcquire/">AQS-cancelAcquire 方法源码解析</a>。</p><p><img src="/images/42-1.png" alt="cancelAcquire"></p><h6 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h6><p>唤醒 node 的后继节点。在前文 <code>cancelAcquire</code> 方法中，如果 <em>node 不是 tail &amp;&amp; pred 是 head</em> 则会调用此方法；另外在释放锁时也会调用此方法。</p><p><code>unparkSuccessor</code> 方法执行逻辑：</p><ol><li>如果 <code>node.waitStatus &lt; 0</code>，即 node 需要给它的后继节点发信号或者说 node 的后继节点需要被唤醒，将 node 的 <code>waitStatus</code> 置为 0（清除预期的信号）</li><li>寻找要 unpark 的后继节点，如果找到，则唤醒它。具体逻辑为：先看 node 的 <code>next</code> 是否符合条件，如果符合就唤醒；如果不符合就从 <code>tail</code> 往前遍历寻找，如果找到就唤醒（这里也同前文提到的 Node 类的 next 指针的作用呼应上了）</li></ol><p><img src="/images/43-17.png" alt="unparkSuccessor"></p><p><code>node.waitStatus &lt; 0</code> 的判断主要是为了清除 node 的 <code>waitStatus</code>，也就是说，此时，无论 node 后的节点是什么状态，无论 node 的后继节点是否被唤醒，只要调用完该方法，node 的状态肯定为 0 或 CANCELLED（node.waitStatus &gt;= 0，即清除了预期的信号）。</p><h4 id="selfInterrupt"><a href="#selfInterrupt" class="headerlink" title="selfInterrupt"></a>selfInterrupt</h4><p>当前线程在等待过程中被中断，中断当前线程。</p><p><img src="/images/43-18.png" alt="selfInterrupt"></p><p>这里可能有人会有疑问，当前线程已经在等待过程中被中断，为什么又要中断一次？</p><p>因为 <code>parkAndCheckInterrupt</code> 方法里 check interrupt 时用的是 <code>Thread.interrupted()</code> 方法，前文提到，该方法除了会返回当前线程是否被中断外，还会重置中断状态。因此，必须在这里补上这次中断。</p><h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><p>该方法用来在独占模式下释放锁。该方法返回值和 <code>tryRelease</code> 方法的返回值一致。</p><p><code>release</code> 方法执行逻辑：</p><ol><li>调用 <code>tryRelease</code> 方法尝试设置同步状态 <code>state</code>，如果 <code>tryRelease</code> 返回 <code>false</code>，则 <code>release</code> 返回 <code>false</code>，否则执行步骤 2</li><li>这两种情况下不做操作，直接返回 <code>true</code>：当 <code>head</code> 节点为空，说明队列为空；当 <code>head</code> 节点不为空且 <code>waitStatus</code> 为 0，说明队列中此时只有一个 <code>head</code> 节点或有其它线程正在执行 <code>unparkSuccessor</code> 方法。否则去调用 <code>unparkSuccessor</code> 方法去唤醒 <code>head</code> 的后继节点，然后返回 <code>true</code></li></ol><p><img src="/images/43-24.png" alt="release"></p><p>当 <code>head</code> 节点的 <code>waitStatus</code> 为 0，此时可能有其它线程正在执行 <code>unparkSuccessor</code> 方法，是不是觉得不可思议，独占锁模式下竟然还会有两个线程同时调用 <code>unparkSuccessor</code> 方法？</p><p>这是有可能的。前文中说过，独占锁模式下，<code>unparkSuccessor</code> 方法可能会有两处调用，一处是在 <code>cancelAcquire</code> 方法中，一处是在 <code>release</code> 方法中。假设这种情况：</p><ol><li>A 线程获取到锁后执行逻辑（还未调用 <code>release</code> 方法）</li><li>B、C 线程获取不到锁，相继入队</li><li>B 线程执行 <code>acquireQueued</code> 方法结果抛异常走到了 <code>cancelAcquire</code> 方法中，执行 <code>compareAndSetWaitStatus(node, ws, 0)</code> 这句成功，然后在满足一系列条件后调用 <code>unparkSuccessor</code> 方法去唤醒 C 线程</li><li>A 线程执行完逻辑后调用 <code>release</code> 方法，此时发现 <code>head</code> 的 <code>waitStatus</code> 等于 0，其实意味着 A 要唤醒后继节点的工作被 B 给做了，那 A 什么都不用做直接 <code>return true</code> 即可</li></ol><h4 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h4><p><code>tryRelease</code> 方法主要是尝试设置同步状态 <code>state</code>。具体逻辑需要子类去实现，默认实现抛出 <code>UnsupportedOperationException</code>。此方法始终由执行 <code>release</code> 的线程调用。返回值 <code>true</code> 表示如果此对象现在处于完全 release 状态，任何等待线程都可以尝试获取；否则返回 <code>false</code>。</p><p>因为要考虑多线程的情况，所以子类在具体实现中可能需要使用 <code>getState</code>、<code>setState</code>、<code>compareAndSetState</code> 等方法检查 和/或 修改同步状态 <code>state</code>。</p><p><img src="/images/43-19.png" alt="tryRelease"></p><p><code>unparkSuccessor</code> 的逻辑前文已介绍，此处不再赘述。另外，别忘了唤醒后还是会继续去获取锁的。</p><h3 id="tryAcquireNanos"><a href="#tryAcquireNanos" class="headerlink" title="tryAcquireNanos"></a>tryAcquireNanos</h3><p>大体逻辑同 <code>acquire</code> 方法，如注释所说，和 <code>acquire</code> 方法不同的是，会先检查中断状态，然后至少调用一次 <code>tryAcquire</code> 方法，在这其中做了超时和中断判断。成功则返回 <code>true</code>，超时则返回 <code>false</code>，中断则抛出 <code>InterruptedException</code>。</p><p><img src="/images/43-20.png" alt="tryAcquireNanos"></p><h4 id="doAcquireNanos"><a href="#doAcquireNanos" class="headerlink" title="doAcquireNanos"></a>doAcquireNanos</h4><p>该方法相当于把前文中说的 <code>addWaiter(Node.EXCLUSIVE)</code> 方法揉进了 <code>acquireQueued()</code> 方法里，并做了超时和中断判断。注意：只有返回 <code>true</code> 时才不会调用 <code>cancelAcquire</code> 方法。</p><p>而且该方法在挂起线程之前做了个判断，当最长等待时间大于 <code>spinForTimeoutThreshold</code> 时，才会挂起。</p><p><code>spinForTimeoutThreshold</code> 字段的作用前文说过，这里再来复述一遍：该值相当于一个阈值，在一些提供等待时间的操作中会使用该值来判断，当等待时间小于该值（即超时时间非常短）时直接自旋，这样可以提高程序的响应能力。</p><p><img src="/images/43-21.png" alt="doAcquireNanos"></p><h3 id="acquireInterruptibly"><a href="#acquireInterruptibly" class="headerlink" title="acquireInterruptibly"></a>acquireInterruptibly</h3><p>大体逻辑同 <code>acquire</code> 方法，如注释所说，和 <code>acquire</code> 方法不同的是，会先检查中断状态，然后至少调用一次 <code>tryAcquire</code> 方法，在这其中做了中断判断。中断则抛出 <code>InterruptedException</code>。</p><p><img src="/images/43-22.png" alt="acquireInterruptibly"></p><h4 id="doAcquireInterruptibly"><a href="#doAcquireInterruptibly" class="headerlink" title="doAcquireInterruptibly"></a>doAcquireInterruptibly</h4><p>该方法相当于把前文中说的 <code>addWaiter(Node.EXCLUSIVE)</code> 方法揉进了 <code>acquireQueued</code> 方法里，并做了中断判断。</p><p><img src="/images/43-23.png" alt="doAcquireInterruptibly"></p><p>至此，AQS <em>独占锁</em>源码就解析完了，下篇文章会继续解析<em>共享锁</em>源码。个人认为共享锁对应的情况更复杂一些，所以也更难理解一些。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;要深入理解 AQS 的源码确实不容易，因为其中有很多情况要考虑，甚至源码中的每一个 if 语句可能就包含着一种或几种情况，尤其是在共享锁部分；另外还有一些因素也要考虑，比如多线程调用、CPU 分配的时间片、虚假唤醒等。&lt;/p&gt;
&lt;p&gt;本文主要内容为 AQS 独占锁源码的深入</summary>
      
    
    
    
    <category term="source code" scheme="http://yangsanity.me/categories/source-code/"/>
    
    
    <category term="jdk source code" scheme="http://yangsanity.me/tags/jdk-source-code/"/>
    
    <category term="AQS" scheme="http://yangsanity.me/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>AQS-cancelAcquire 方法源码解析</title>
    <link href="http://yangsanity.me/2021/08/16/AQS-cancelAcquire/"/>
    <id>http://yangsanity.me/2021/08/16/AQS-cancelAcquire/</id>
    <published>2021-08-16T05:16:45.000Z</published>
    <updated>2022-06-06T02:55:52.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>AQS 的 <code>cancelAcquire</code> 方法值得花一篇文章来写，因为虽然代码不多，但是涉及到的情况不少。</p><p><img src="/images/42-1.png" alt="cancelAcquire"></p><p>在 AQS 源码中该方法共被 6 个地方调用（3 个独占锁，3 个共享锁）：<br><code>acquireQueued</code> / <code>doAcquireInterruptibly</code> / <code>doAcquireNanos</code><br><code>doAcquireShared</code> / <code>doAcquireSharedInterruptibly</code> / <code>doAcquireSharedNanos</code></p><p>该方法目的为：获取过程抛出异常后，取消正在进行的获取尝试。</p><p>不考虑 Condition 的前提下，该方法是唯一会将 sync queue 中 Node 的 waitStatus 置为 CANCELLED 的方法。</p><h2 id="穷举所有-case"><a href="#穷举所有-case" class="headerlink" title="穷举所有 case"></a>穷举所有 case</h2><p>从该方法最后部分 <code>if (node == tail &amp;&amp; ...</code> 和 <code>if (pred != head &amp;&amp; ...</code> 两句可以看出，该方法进行操作的三个不同的大前提条件为：</p><ol><li>node 是 tail</li><li>node 不是 tail &amp;&amp; pred 不是 head</li><li>node 不是 tail &amp;&amp; pred 是 head</li></ol><p>我们先不考虑这些 case 如何达成，本文我们暂时只关注：<strong>穷举出所有 case 并看每种 case 的最终结果</strong>。</p><p><em>注：下文中 normalNode 代表 waitStatus &lt;= 0 的节点；cancelNode 代表 waitStatus 为 CANCELLED 的节点。</em></p><ol><li>node 是 tail <strong>+</strong> pred 是 head<blockquote><p>head &lt;=&gt; <em>[node]</em><br>head &lt;=&gt; cancelNode &lt;=&gt; <em>[node]</em></p></blockquote></li><li>node 是 tail <strong>+</strong> pred 不是 head<blockquote><p>head &lt;=&gt; normalNode &lt;=&gt; <em>[node]</em><br>head &lt;=&gt; normalNode &lt;=&gt; cancelNode &lt;=&gt; <em>[node]</em></p></blockquote></li><li>node 不是 tail &amp;&amp; pred 不是 head <strong>+</strong> node 后为 normalNode<blockquote><p>head &lt;=&gt; normalNode &lt;=&gt; <em>[node]</em> &lt;=&gt; normalNode<br>head &lt;=&gt; normalNode &lt;=&gt; cancelNode &lt;=&gt; <em>[node]</em> &lt;=&gt; normalNode</p></blockquote></li><li>node 不是 tail &amp;&amp; pred 不是 head <strong>+</strong> node 后为 cancelNode<blockquote><p>head &lt;=&gt; normalNode &lt;=&gt; <em>[node]</em> &lt;=&gt; cancelNode<br>head &lt;=&gt; normalNode &lt;=&gt; cancelNode &lt;=&gt; <em>[node]</em> &lt;=&gt; cancelNode</p></blockquote></li><li>node 不是 tail &amp;&amp; pred 是 head <strong>+</strong> node 后为 normalNode<blockquote><p>head &lt;=&gt; <em>[node]</em> &lt;=&gt; normalNode<br>head &lt;=&gt; cancelNode &lt;=&gt; <em>[node]</em> &lt;=&gt; normalNode</p></blockquote></li><li>node 不是 tail &amp;&amp; pred 是 head <strong>+</strong> node 后为 cancelNode<blockquote><p>head &lt;=&gt; <em>[node]</em> &lt;=&gt; cancelNode<br>head &lt;=&gt; cancelNode &lt;=&gt; <em>[node]</em> &lt;=&gt; cancelNode</p></blockquote></li></ol><p>（在下文中会看到，其实 5 和 6 是可以合并的）</p><h2 id="node-是-tail-pred-是-head"><a href="#node-是-tail-pred-是-head" class="headerlink" title="node 是 tail + pred 是 head"></a>node 是 tail <strong>+</strong> pred 是 head</h2><h3 id="case1-1"><a href="#case1-1" class="headerlink" title="case1.1"></a>case1.1</h3><blockquote><p>head &lt;=&gt; <em>[node]</em></p></blockquote><p><img src="/images/42-2.png" alt="case1.1"></p><h3 id="case1-2"><a href="#case1-2" class="headerlink" title="case1.2"></a>case1.2</h3><blockquote><p>head &lt;=&gt; cancelNode &lt;=&gt; <em>[node]</em></p></blockquote><p><img src="/images/42-3.png" alt="case1.2"></p><h3 id="何时清除-node"><a href="#何时清除-node" class="headerlink" title="何时清除 node"></a>何时清除 node</h3><p>当 head 节点变更时，即前置线程释放锁，sync queue 中第一个排队线程获取锁后调用了 <code>setHead</code> 方法和 <code>p.next = null</code> 后。</p><h2 id="node-是-tail-pred-不是-head"><a href="#node-是-tail-pred-不是-head" class="headerlink" title="node 是 tail + pred 不是 head"></a>node 是 tail <strong>+</strong> pred 不是 head</h2><h3 id="case2-1"><a href="#case2-1" class="headerlink" title="case2.1"></a>case2.1</h3><blockquote><p>head &lt;=&gt; normalNode &lt;=&gt; <em>[node]</em></p></blockquote><p><img src="/images/42-4.png" alt="case2.1"></p><h3 id="case2-2"><a href="#case2-2" class="headerlink" title="case2.2"></a>case2.2</h3><blockquote><p>head &lt;=&gt; normalNode &lt;=&gt; cancelNode &lt;=&gt; <em>[node]</em></p></blockquote><p><img src="/images/42-5.png" alt="case2.2"></p><h3 id="何时清除-node-1"><a href="#何时清除-node-1" class="headerlink" title="何时清除 node"></a>何时清除 node</h3><p>当排队线程陆续获取锁直到 pred 变为 head，然后（同 case1）当 head 节点变更时，即前置线程释放锁，sync queue 中第一个排队线程获取锁后调用了 <code>setHead</code> 方法和 <code>p.next = null</code> 后。</p><h2 id="node-不是-tail-amp-amp-pred-不是-head-node-后为-normalNode"><a href="#node-不是-tail-amp-amp-pred-不是-head-node-后为-normalNode" class="headerlink" title="node 不是 tail &amp;&amp; pred 不是 head + node 后为 normalNode"></a>node 不是 tail &amp;&amp; pred 不是 head <strong>+</strong> node 后为 normalNode</h2><h3 id="case3-1"><a href="#case3-1" class="headerlink" title="case3.1"></a>case3.1</h3><blockquote><p>head &lt;=&gt; normalNode &lt;=&gt; <em>[node]</em> &lt;=&gt; normalNode</p></blockquote><p><img src="/images/42-6.png" alt="case3.1"></p><h3 id="case3-2"><a href="#case3-2" class="headerlink" title="case3.2"></a>case3.2</h3><blockquote><p>head &lt;=&gt; normalNode &lt;=&gt; cancelNode &lt;=&gt; <em>[node]</em> &lt;=&gt; normalNode</p></blockquote><p><img src="/images/42-7.png" alt="case3.2"></p><h3 id="何时清除-node-2"><a href="#何时清除-node-2" class="headerlink" title="何时清除 node"></a>何时清除 node</h3><p>当别的线程调用 <code>shouldParkAfterFailedAcquire</code> 或 <code>cancelAcquire</code> 方法时，会调整其遍历节点的指针，（同 case2）当排队线程陆续获取锁直到 node 后的 normalNode 变为 head，然后当 head 节点变更时，即前置线程释放锁，sync queue 中第一个排队线程获取锁后调用了 <code>setHead</code> 方法和 <code>p.next = null</code> 后。</p><h2 id="node-不是-tail-amp-amp-pred-不是-head-node-后为-cancelNode"><a href="#node-不是-tail-amp-amp-pred-不是-head-node-后为-cancelNode" class="headerlink" title="node 不是 tail &amp;&amp; pred 不是 head + node 后为 cancelNode"></a>node 不是 tail &amp;&amp; pred 不是 head <strong>+</strong> node 后为 cancelNode</h2><h3 id="case4-1"><a href="#case4-1" class="headerlink" title="case4.1"></a>case4.1</h3><blockquote><p>head &lt;=&gt; normalNode &lt;=&gt; <em>[node]</em> &lt;=&gt; cancelNode</p></blockquote><p><img src="/images/42-8.png" alt="case4.1"></p><h3 id="case4-2"><a href="#case4-2" class="headerlink" title="case4.2"></a>case4.2</h3><blockquote><p>head &lt;=&gt; normalNode &lt;=&gt; cancelNode &lt;=&gt; <em>[node]</em> &lt;=&gt; cancelNode</p></blockquote><p><img src="/images/42-9.png" alt="case4.2"></p><h3 id="何时清除-node-3"><a href="#何时清除-node-3" class="headerlink" title="何时清除 node"></a>何时清除 node</h3><p>当 node 后面的 cancelNode 后面有了 normalNode，（同 case3）当别的线程调用 <code>shouldParkAfterFailedAcquire</code> 或 <code>cancelAcquire</code> 方法时，会调整其遍历节点的指针，当排队线程陆续获取锁直到 node 后的 normalNode 变为 head，然后当 head 节点变更时，即前置线程释放锁，sync queue 中第一个排队线程获取锁后调用了 <code>setHead</code> 方法和 <code>p.next = null</code> 后。</p><h2 id="case5-case6"><a href="#case5-case6" class="headerlink" title="case5 + case6"></a>case5 + case6</h2><p>case5：node 不是 tail &amp;&amp; pred 是 head <strong>+</strong> node 后为 normalNode<br>case6：node 不是 tail &amp;&amp; pred 是 head <strong>+</strong> node 后为 cancelNode</p><p>可以发现，其实该方法的操作不会涉及到 node 后所跟的节点，因此，无论 node 后跟的是 normalNode 或 cancelNode，结果其实都是一样的。</p><h3 id="case5-1-case6-1"><a href="#case5-1-case6-1" class="headerlink" title="case5.1 + case6.1"></a>case5.1 + case6.1</h3><blockquote><p>head &lt;=&gt; <em>[node]</em> &lt;=&gt; normalNode<br>head &lt;=&gt; <em>[node]</em> &lt;=&gt; cancelNode</p></blockquote><p><img src="/images/42-10.png" alt="case5.1"></p><h3 id="case5-2-case6-2"><a href="#case5-2-case6-2" class="headerlink" title="case5.2 + case6.2"></a>case5.2 + case6.2</h3><blockquote><p>head &lt;=&gt; cancelNode &lt;=&gt; <em>[node]</em> &lt;=&gt; normalNode<br>head &lt;=&gt; cancelNode &lt;=&gt; <em>[node]</em> &lt;=&gt; cancelNode</p></blockquote><p><img src="/images/42-11.png" alt="case5.2"></p><h3 id="何时清除-node-4"><a href="#何时清除-node-4" class="headerlink" title="何时清除 node"></a>何时清除 node</h3><ol><li>当 node 后是 normalNode 时，会唤醒线程去获取锁，获取到锁后该节点变为头节点，注意此时 node 其实还没有彻底清除掉，还需要此后（同 case1）当 head 节点变更时，即前置线程释放锁，sync queue 中第一个排队线程获取锁后调用了 <code>setHead</code> 方法后</li><li>当 node 后是 cancelNode 时，啥也不会做，因为唤不醒该线程，只能等（同 case4）当 node 后面的 cancelNode 后面有了 normalNode，当别的线程调用 <code>shouldParkAfterFailedAcquire</code> 或 <code>cancelAcquire</code> 方法时，会调整其遍历节点的指针，当排队线程陆续获取锁直到 node 后的 normalNode 变为 head，然后当 head 节点变更时，即前置线程释放锁，sync queue 中第一个排队线程获取锁后调用了 <code>setHead</code> 方法和 <code>p.next = null</code> 后</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>该方法无论什么条件，都会做的事是：</p><ol><li>pred 指向从 node 往前遍历的第一个状态不为 CANCELLED 的节点</li><li>node.prev 指向 pred</li><li>node 的 waitStatus 置为 CANCELLED</li></ol><p>此后，当条件为：</p><ol><li>node 是 tail：将 tail 指向 pred；将 pred.next 指向 null</li><li>node 不是 tail &amp;&amp; pred 不是 head：将 pred 的 waitStatus 置为 SIGNAL；如果 node.next 的 waitStatus 不为 CANCELLED，将 pred.next 指向 node.next</li><li>node 不是 tail &amp;&amp; pred 是 head：调用 unparkSuccessor 方法唤醒 node 的后继节点</li></ol><p>可以发现该方法很多结果最终都是修改 next 指针而保留 prev 指针，我认为这是因为考虑到还有很多方法都采用从 tail 往前遍历，而遍历时会跳过 waitStatus 为 CANCELLED 的节点。因此在这里只要修改节点的 waitStatus 以及 next 指针就足够了，早晚都会有别的方法会通过遍历 / <code>setHead</code> / <code>p.next = null</code> 去将 waitStatus 为 CANCELLED 的节点从 sync queue 中完全断开！</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;AQS 的 &lt;code&gt;cancelAcquire&lt;/code&gt; 方法值得花一篇文章来写，因为虽然代码不多，但是涉及到的情况不少。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="source code" scheme="http://yangsanity.me/categories/source-code/"/>
    
    
    <category term="jdk source code" scheme="http://yangsanity.me/tags/jdk-source-code/"/>
    
    <category term="AQS" scheme="http://yangsanity.me/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>探究 interrupt() 和 park() 的影响</title>
    <link href="http://yangsanity.me/2021/08/12/InterruptPark/"/>
    <id>http://yangsanity.me/2021/08/12/InterruptPark/</id>
    <published>2021-08-12T02:02:38.000Z</published>
    <updated>2022-05-07T02:09:59.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文产生原因源于 AQS 中的 parkAndCheckInterrupt() 方法。</p><p><img src="/images/41-1.png" alt="AQS-parkAndCheckInterrupt"></p><p>如注释所说，该方法的作用为：挂起线程后检查是否中断，如果被中断则返回 true。</p><p>该方法被调用的时机为：获取锁失败，线程在同步队列中挂起自己，等待被唤醒后继续获取锁。</p><p>问题：我们只是需要知道线程是否在等待时中断而已，为什么返回值不用 Thread.currentThread().isInterrupted() 方法？</p><p>前置知识：</p><ol><li>中断线程可以唤醒被挂起的线程</li><li>Thread#isInterrupted() 和 Thread.interrupted() 的区别是：后者会重置中断状态</li></ol><p>本文将扩展一下标题所述的范围，通过几个 demo 来探究一下 <code>Thread#interrupt()</code> / <code>Thread.interrupted()</code> / <code>Thread.sleep()</code> / <code>LockSupport.park()</code> / <code>LockSupport.unpark()</code> 之间的一些影响。</p><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p><img src="/images/41-2.png" alt="java-version"></p><p><em>注：为了保证结果严谨性，每个 demo 都会包含多线程和单线程的模拟。</em></p><h2 id="case1-interrupt-and-park"><a href="#case1-interrupt-and-park" class="headerlink" title="case1: interrupt and park"></a>case1: interrupt and park</h2><p>A 线程多次调用 LockSupport.park() 挂起自己，B 线程调用 interrupt() 中断 A 线程 or<br>A 线程先调用 interrupt() 中断自己，再多次调用 LockSupport.park() 挂起自己</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A 线程多次调用 LockSupport.park() 挂起自己，B 线程调用 interrupt() 中断 A 线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Test1 t = <span class="keyword">new</span> Test1();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before first park&quot;</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;after first park&quot;</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;final park&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A 线程先调用 interrupt() 中断自己，再多次调用 LockSupport.park() 挂起自己</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test1 t = <span class="keyword">new</span> Test1();</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            System.out.println(<span class="string">&quot;before first park&quot;</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;after first park&quot;</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;final park&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="/images/41-3.png" alt="case1-result"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>调用 interrupt() 方法中断线程前，线程会正常挂起；中断后，无论调用多少次 LockSupport.park()，线程都不会挂起，而是正常运行结束。</p><h2 id="case2-interrupt-and-park-and-interrupted"><a href="#case2-interrupt-and-park-and-interrupted" class="headerlink" title="case2: interrupt and park and interrupted"></a>case2: interrupt and park and interrupted</h2><p>（在 case1 的基础上）<br>A 线程多次调用 LockSupport.park() 挂起自己后调用 Thread.interrupted() 重置中断状态，最后再调用 LockSupport.park() 挂起自己，B 线程调用 interrupt() 中断 A 线程 or<br>A 线程先调用 interrupt() 中断自己，再多次调用 LockSupport.park() 挂起自己，然后调用 Thread.interrupted() 重置中断状态，最后再调用 LockSupport.park() 挂起自己</p><h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A 线程多次调用 LockSupport.park() 挂起自己后调用 Thread.interrupted() 重置中断状态，最后再调用 LockSupport.park() 挂起自己，B 线程调用 interrupt() 中断 A 线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Test2 t = <span class="keyword">new</span> Test2();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before first park&quot;</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;after first park&quot;</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;after second park&quot;</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;after third park&quot;</span>);</span><br><span class="line">            System.out.println(Thread.interrupted()); <span class="comment">// true</span></span><br><span class="line">            System.out.println(Thread.interrupted()); <span class="comment">// false</span></span><br><span class="line">            LockSupport.park(); <span class="comment">// 挂起</span></span><br><span class="line">            System.out.println(<span class="string">&quot;final park&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A 线程先调用 interrupt() 中断自己，再多次调用 LockSupport.park() 挂起自己，然后调用 Thread.interrupted() 重置中断状态，最后再调用 LockSupport.park() 挂起自己</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test2 t = <span class="keyword">new</span> Test2();</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            System.out.println(<span class="string">&quot;before first park&quot;</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;after first park&quot;</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;after second park&quot;</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;after third park&quot;</span>);</span><br><span class="line">            System.out.println(Thread.interrupted()); <span class="comment">// true</span></span><br><span class="line">            System.out.println(Thread.interrupted()); <span class="comment">// false</span></span><br><span class="line">            LockSupport.park(); <span class="comment">// 挂起</span></span><br><span class="line">            System.out.println(<span class="string">&quot;final park&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p><img src="/images/41-4.png" alt="case2-result"></p><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>（结合 case1 的结论）<br>调用 interrupt() 方法中断线程前，线程会正常挂起；中断后，无论调用多少次 LockSupport.park()，线程都不会挂起，直到重置中断状态后，再次调用 LockSupport.park() 线程才会挂起。</p><h2 id="case3-interrupt-and-park-and-interrupted-2"><a href="#case3-interrupt-and-park-and-interrupted-2" class="headerlink" title="case3 interrupt and park and interrupted 2"></a>case3 interrupt and park and interrupted 2</h2><p>（在 case2 的基础上）<br>将调用 Thread.interrupted() 重置中断状态提前到 interrupt() 中断后，再多次调用 LockSupport.park()。即 Thread.interrupted() 后先立即进行重置中断状态操作。</p><h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test3 t = <span class="keyword">new</span> Test3();</span><br><span class="line">        t.start();</span><br><span class="line">        t.interrupt();</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;&#125;</span><br><span class="line">            System.out.println(Thread.interrupted()); <span class="comment">// true</span></span><br><span class="line">            System.out.println(Thread.interrupted()); <span class="comment">// false</span></span><br><span class="line">            System.out.println(<span class="string">&quot;before first park&quot;</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;after first park&quot;</span>);</span><br><span class="line">            LockSupport.park(); <span class="comment">// 挂起</span></span><br><span class="line">            System.out.println(<span class="string">&quot;final park&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test3 t = <span class="keyword">new</span> Test3();</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            System.out.println(Thread.interrupted()); <span class="comment">// true</span></span><br><span class="line">            System.out.println(Thread.interrupted()); <span class="comment">// false</span></span><br><span class="line">            System.out.println(<span class="string">&quot;before first park&quot;</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;after first park&quot;</span>);</span><br><span class="line">            LockSupport.park(); <span class="comment">// 挂起</span></span><br><span class="line">            System.out.println(<span class="string">&quot;final park&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><p><img src="/images/41-5.png" alt="case3-result"></p><h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p>调用 interrupt() 方法中断线程然后立即重置中断状态，之后，第一次调用 LockSupport.park() 不会挂起线程，再次调用 LockSupport.park() 线程才会挂起。</p><h2 id="case4-sleep-and-park"><a href="#case4-sleep-and-park" class="headerlink" title="case4: sleep and park"></a>case4: sleep and park</h2><p>A 线程 sleep 时被 B 线程中断后，再多次调用 LockSupport.park()。</p><h3 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A 线程 sleep 时被 B 线程中断后，再多次调用 LockSupport.park()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test4 t = <span class="keyword">new</span> Test4();</span><br><span class="line">        t.start();</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;sleep end&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.out.println(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;before first park&quot;</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;after first park&quot;</span>);</span><br><span class="line">            LockSupport.park(); <span class="comment">// 挂起</span></span><br><span class="line">            System.out.println(<span class="string">&quot;final park&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h3><p><img src="/images/41-6.png" alt="case4-result"></p><h3 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h3><p>（类似 case3 的结论）<br>线程 sleep 时被中断抛出 InterruptedException 重置中断状态，之后，第一次调用 LockSupport.park() 不会挂起线程，再次调用 LockSupport.park() 线程才会挂起。</p><h2 id="case5-unpark-and-park"><a href="#case5-unpark-and-park" class="headerlink" title="case5: unpark and park"></a>case5: unpark and park</h2><p>A 线程多次调用 LockSupport.unpark(threadB)，B 线程多次调用 LockSupport.park() 挂起自己 or<br>A 线程多次调用 LockSupport.unpark(threadA)，再多次调用 LockSupport.park() 挂起自己</p><h3 id="code-4"><a href="#code-4" class="headerlink" title="code"></a>code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A 线程多次调用 LockSupport.unpark(threadB)，B 线程多次调用 LockSupport.park() 挂起自己</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test5 t = <span class="keyword">new</span> Test5();</span><br><span class="line">        t.start();</span><br><span class="line">        LockSupport.unpark(t);</span><br><span class="line">        LockSupport.unpark(t);</span><br><span class="line">        LockSupport.unpark(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;before first park&quot;</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;after first park&quot;</span>);</span><br><span class="line">            LockSupport.park(); <span class="comment">// 挂起</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;final park&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A 线程多次调用 LockSupport.unpark(threadA)，再多次调用 LockSupport.park() 挂起自己</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test5 t = <span class="keyword">new</span> Test5();</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            LockSupport.unpark(Thread.currentThread());</span><br><span class="line">            LockSupport.unpark(Thread.currentThread());</span><br><span class="line">            LockSupport.unpark(Thread.currentThread());</span><br><span class="line">            System.out.println(<span class="string">&quot;before first park&quot;</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;after first park&quot;</span>);</span><br><span class="line">            LockSupport.park(); <span class="comment">// 挂起</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;final park&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果-4"><a href="#结果-4" class="headerlink" title="结果"></a>结果</h3><p><img src="/images/41-7.png" alt="case5-result"></p><h3 id="结论-4"><a href="#结论-4" class="headerlink" title="结论"></a>结论</h3><p>无论调用多少次 LockSupport.unpark(thread)，都只会提供给线程一个许可。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，前言中问题的原因就比较清晰了：中断后，如果不清除中断状态，下次 park 是不生效的。</p><p>假如该线程下次仍然获取锁失败，再调用 parkAndCheckInterrupt() 就不能再挂起自己了。因此这里需要一个又能重置线程中断状态又能返回线程是否中断的方法，Thread.interrupted() 方法是再合适不过了。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文产生原因源于 AQS 中的 parkAndCheckInterrupt() 方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/4</summary>
      
    
    
    
    <category term="code demo" scheme="http://yangsanity.me/categories/code-demo/"/>
    
    
    <category term="AQS" scheme="http://yangsanity.me/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>AQS 基础--多图详解 CLH 锁的原理与实现</title>
    <link href="http://yangsanity.me/2021/08/10/CLHLock/"/>
    <id>http://yangsanity.me/2021/08/10/CLHLock/</id>
    <published>2021-08-10T06:25:36.000Z</published>
    <updated>2022-05-18T09:30:16.081Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自公众号 “源码笔记”。</p><h2 id="什么是自旋锁和互斥锁？"><a href="#什么是自旋锁和互斥锁？" class="headerlink" title="什么是自旋锁和互斥锁？"></a>什么是自旋锁和互斥锁？</h2><p>由于CLH锁是一种自旋锁，那么我们先来看看自旋锁是什么？</p><p><em>自旋锁</em>说白了也是一种互斥锁，只不过没有抢到锁的线程会一直自旋等待锁的释放，处于<em>busy-waiting</em>的状态，此时等待锁的线程不会进入休眠状态，而是一直忙等待浪费CPU周期。<em>因此自旋锁适用于锁占用时间短的场合。</em></p><p>这里谈到了自旋锁，那么我们也顺便说下互斥锁。这里的<em>互斥锁</em>说的是传统意义的互斥锁，就是多个线程并发竞争锁的时候，没有抢到锁的线程会进入休眠状态即<em>sleep-waiting</em>，当锁被释放的时候，处于休眠状态的一个线程会再次获取到锁。缺点就是这一些列过程需要线程切换，需要执行很多CPU指令，同样需要时间。如果CPU执行线程切换的时间比锁占用的时间还长，那么可能还不如使用自旋锁。<em>因此互斥锁适用于锁占用时间长的场合。</em></p><h2 id="什么是CLH锁？"><a href="#什么是CLH锁？" class="headerlink" title="什么是CLH锁？"></a>什么是CLH锁？</h2><p><em>CLH锁</em>其实就是一种是基于逻辑队列非线程饥饿的一种自旋公平锁，由于是 Craig、Landin 和 Hagersten三位大佬的发明，因此命名为CLH锁。</p><p><em>CLH锁原理如下：</em></p><ol><li>首先有一个尾节点指针，通过这个尾结点指针来构建等待线程的逻辑队列，因此能确保线程线程先到先服务的公平性，因此尾指针可以说是构建逻辑队列的桥梁；此外这个尾节点指针是原子引用类型，避免了多线程并发操作的线程安全性问题；</li><li>通过等待锁的每个线程在自己的某个变量上自旋等待，这个变量将由前一个线程写入。由于某个线程获取锁操作时总是通过尾节点指针获取到前一线程写入的变量，而尾节点指针又是原子引用类型，因此确保了这个变量获取出来总是线程安全的。</li></ol><p>这么说肯定很抽象，有些小伙伴可能不理解，没关系，我们心中可以有个概念即可，后面我们会一步一图来彻彻底底把CLH锁弄明白。</p><h2 id="为什么要学习CLH锁？"><a href="#为什么要学习CLH锁？" class="headerlink" title="为什么要学习CLH锁？"></a>为什么要学习CLH锁？</h2><p>好了，前面我们对CLH锁有了一个概念后，那么我们为什么要学习CLH锁呢？</p><p>研究过AQS源码的小伙伴们应该知道，AQS是JUC的核心，而CLH锁又是AQS的基础，说核心也不为过，因为AQS就是用了变种的CLH锁。如果要学好Java并发编程，那么必定要学好JUC；学好JUC，必定要先学好AQS；学好AQS，那么必定先学好CLH。因此，这就是我们为什么要学习CLH锁的原因。</p><h2 id="CLH锁详解"><a href="#CLH锁详解" class="headerlink" title="CLH锁详解"></a>CLH锁详解</h2><p>那么，下面我们先来看CLH锁实现代码，然后通过一步一图来详解CLH锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CLHLock.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLHLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CLH锁节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CLHNode</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 锁状态：默认为false，表示线程没有获取到锁；true表示线程获取到锁或正在等待</span></span><br><span class="line">        <span class="comment">// 为了保证locked状态是线程间可见的，因此用volatile关键字修饰</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尾结点，总是指向最后一个CLHNode节点</span></span><br><span class="line">    <span class="comment">// 【注意】这里用了java的原子系列之AtomicReference，能保证原子更新</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;CLHNode&gt; tailNode;</span><br><span class="line">    <span class="comment">// 当前节点的前继节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;CLHNode&gt; predNode;</span><br><span class="line">    <span class="comment">// 当前节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;CLHNode&gt; curNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CLHLock构造函数，用于新建CLH锁节点时做一些初始化逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CLHLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化时尾结点指向一个空的CLH节点</span></span><br><span class="line">        tailNode = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="keyword">new</span> CLHNode());</span><br><span class="line">        <span class="comment">// 初始化当前的CLH节点</span></span><br><span class="line">        curNode = ThreadLocal.withInitial(CLHNode::<span class="keyword">new</span>);</span><br><span class="line">        <span class="comment">// 初始化前继节点，注意此时前继节点没有存储CLHNode对象，存储的是null</span></span><br><span class="line">        predNode = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取出当前线程ThreadLocal存储的当前节点，初始化值总是一个新建的CLHNode，locked状态为false。</span></span><br><span class="line">        CLHNode currNode = curNode.get();</span><br><span class="line">        <span class="comment">// 此时把lock状态置为true，表示一个有效状态，</span></span><br><span class="line">        <span class="comment">// 即获取到了锁或正在等待锁的状态</span></span><br><span class="line">        currNode.locked = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 当一个线程到来时，总是将尾结点取出来赋值给当前线程的前继节点；</span></span><br><span class="line">        <span class="comment">// 然后再把当前线程的当前节点赋值给尾节点</span></span><br><span class="line">        <span class="comment">// 【注意】在多线程并发情况下，这里通过AtomicReference类能防止并发问题</span></span><br><span class="line">        <span class="comment">// 【注意】哪个线程先执行到这里就会先执行predNode.set(preNode);语句，因此构建了一条逻辑线程等待链</span></span><br><span class="line">        <span class="comment">// 这条链避免了线程饥饿现象发生</span></span><br><span class="line">        CLHNode preNode = tailNode.getAndSet(currNode);</span><br><span class="line">        <span class="comment">// 将刚获取的尾结点（前一线程的当前节点）赋给当前线程的前继节点ThreadLocal</span></span><br><span class="line">        <span class="comment">// 【思考】这句代码也可以去掉吗，如果去掉有影响吗？</span></span><br><span class="line">        predNode.set(preNode);</span><br><span class="line">        <span class="comment">// 【1】若前继节点的locked状态为false，则表示获取到了锁，不用自旋等待；</span></span><br><span class="line">        <span class="comment">// 【2】若前继节点的locked状态为true，则表示前一线程获取到了锁或者正在等待，自旋等待</span></span><br><span class="line">        <span class="keyword">while</span> (preNode.locked) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 没能获取到锁，进行自旋等待。。。&quot;</span>);</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 能执行到这里，说明当前线程获取到了锁</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 获取到了锁！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前线程的当前节点</span></span><br><span class="line">        CLHNode node = curNode.get();</span><br><span class="line">        <span class="comment">// 进行解锁操作</span></span><br><span class="line">        <span class="comment">// 这里将locked至为false，此时执行了lock方法正在自旋等待的后继节点将会获取到锁</span></span><br><span class="line">        <span class="comment">// 【注意】而不是所有正在自旋等待的线程去并发竞争锁</span></span><br><span class="line">        node.locked = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 释放了锁！！！&quot;</span>);</span><br><span class="line">        <span class="comment">// 小伙伴们可以思考下，下面两句代码的作用是什么？？</span></span><br><span class="line">        CLHNode newCurNode = <span class="keyword">new</span> CLHNode();</span><br><span class="line">        curNode.set(newCurNode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【优化】能提高GC效率和节省内存空间，请思考：这是为什么？</span></span><br><span class="line">        <span class="comment">// curNode.set(predNode.get());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CLH锁的初始化逻辑"><a href="#CLH锁的初始化逻辑" class="headerlink" title="CLH锁的初始化逻辑"></a>CLH锁的初始化逻辑</h3><p>通过上面代码，我们缕一缕CLH锁的初始化逻辑先：</p><ol><li>定义了一个<code>CLHNode</code>节点，里面有一个<code>locked</code>属性，表示线程线程是否获得锁，默认为<code>false</code>。<code>false</code>表示线程没有获取到锁或已经释放锁；<code>true</code>表示线程获取到了锁或者正在自旋等待。<blockquote><p>注意，为了保证<code>locked</code>属性线程间可见，该属性被<code>volatile</code>修饰。</p></blockquote></li><li><code>CLHLock</code>有三个重要的成员变量尾节点指针<code>tailNode</code>,当前线程的前继节点<code>preNode</code>和当前节点<code>curNode</code>。其中<code>tailNode</code>是<code>AtomicReference</code>类型，目的是为了保证尾节点的线程安全性；此外，<code>preNode</code>和<code>curNode</code>都是<code>ThreadLocal</code>类型即线程本地变量类型，用来保存每个线程的前继<code>CLHNode</code>和当前<code>CLHNode</code>节点。</li><li>最重要的是我们新建一把<code>CLHLock</code>对象时，此时会执行构造函数里面的初始化逻辑。此时给尾指针<code>tailNode</code>和当前节点<code>curNode</code>初始化一个<code>locked</code>状态为<code>false</code>的<code>CLHNode</code>节点，此时前继节点<code>preNode</code>存储的是<code>null</code>。</li></ol><h3 id="CLH锁的加锁过程"><a href="#CLH锁的加锁过程" class="headerlink" title="CLH锁的加锁过程"></a>CLH锁的加锁过程</h3><p>我们再来看看CLH锁的加锁过程，下面再贴一遍加锁<code>lock</code>方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CLHLock.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取出当前线程ThreadLocal存储的当前节点，初始化值总是一个新建的CLHNode，locked状态为false。</span></span><br><span class="line">    CLHNode currNode = curNode.get();</span><br><span class="line">    <span class="comment">// 此时把lock状态置为true，表示一个有效状态，</span></span><br><span class="line">    <span class="comment">// 即获取到了锁或正在等待锁的状态</span></span><br><span class="line">    currNode.locked = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 当一个线程到来时，总是将尾结点取出来赋值给当前线程的前继节点；</span></span><br><span class="line">    <span class="comment">// 然后再把当前线程的当前节点赋值给尾节点</span></span><br><span class="line">    <span class="comment">// 【注意】在多线程并发情况下，这里通过AtomicReference类能防止并发问题</span></span><br><span class="line">    <span class="comment">// 【注意】哪个线程先执行到这里就会先执行predNode.set(preNode);语句，因此构建了一条逻辑线程等待链</span></span><br><span class="line">    <span class="comment">// 这条链避免了线程饥饿现象发生</span></span><br><span class="line">    CLHNode preNode = tailNode.getAndSet(currNode);</span><br><span class="line">    <span class="comment">// 将刚获取的尾结点（前一线程的当前节点）赋给当前线程的前继节点ThreadLocal</span></span><br><span class="line">    <span class="comment">// 【思考】这句代码也可以去掉吗，如果去掉有影响吗？</span></span><br><span class="line">    predNode.set(preNode);</span><br><span class="line">    <span class="comment">// 【1】若前继节点的locked状态为false，则表示获取到了锁，不用自旋等待；</span></span><br><span class="line">    <span class="comment">// 【2】若前继节点的locked状态为true，则表示前一线程获取到了锁或者正在等待，自旋等待</span></span><br><span class="line">    <span class="keyword">while</span> (preNode.locked) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 没能获取到锁，进行自旋等待。。。&quot;</span>);</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 能执行到这里，说明当前线程获取到了锁</span></span><br><span class="line">    System.out.println(<span class="string">&quot;线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 获取到了锁！！！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然代码的注释已经很详细，我们还是缕一缕线程加锁的过程：</p><ol><li>首先获得当前线程的当前节点<code>curNode</code>，这里每次获取的<code>CLHNode</code>节点的<code>locked</code>状态都为<code>false</code>；</li><li>然后将当前<code>CLHNode</code>节点的<code>locked</code>状态赋值为<code>true</code>，表示当前线程的一种有效状态，即获取到了锁或正在等待锁的状态；</li><li>因为尾指针<code>tailNode</code>的总是指向了前一个线程的<code>CLHNode</code>节点，因此这里利用尾指针<code>tailNode</code>取出前一个线程的<code>CLHNode</code>节点，然后赋值给当前线程的前继节点<code>predNode</code>，并且将尾指针重新指向最后一个节点即当前线程的当前<code>CLHNode</code>节点，以便下一个线程到来时使用；</li><li>根据前继节点（前一个线程）的<code>locked</code>状态判断，若<code>locked</code>为<code>false</code>，则说明前一个线程释放了锁，当前线程即可获得锁，不用自旋等待；若前继节点的<code>locked</code>状态为<code>true</code>，则表示前一线程获取到了锁或者正在等待，自旋等待。</li></ol><p>为了更通俗易懂，我们用一个图来说明。</p><p><em>假如有这么一个场景：</em>有四个并发线程同时启动执行lock操作，假如四个线程的实际执行顺序为：threadA&lt;–threadB&lt;–threadC&lt;–threadD</p><p><em>第一步</em>，线程A过来，执行了lock操作，获得了锁，此时<code>locked</code>状态为<code>true</code>，如下图：</p><p><img src="/images/40-1.png" alt="4.2-1"></p><p><em>第二步</em>，线程B过来，执行了lock操作，由于线程A还未释放锁，此时自旋等待，<code>locked</code>状态也为<code>true</code>，如下图：</p><p><img src="/images/40-2.png" alt="4.2-2"></p><p>第三步，线程C过来，执行了lock操作，由于线程B处于自旋等待，此时线程C也自旋等待（因此CLH锁是公平锁），<code>locked</code>状态也为<code>true</code>，如下图：</p><p><img src="/images/40-3.png" alt="4.2-3"></p><p>第四步，线程D过来，执行了lock操作，由于线程C处于自旋等待，此时线程D也自旋等待，<code>locked</code>状态也为<code>true</code>，如下图：</p><p><img src="/images/40-4.png" alt="4.2-4"></p><p>这就是多个线程并发加锁的一个过程图解，当前线程只要判断前一线程的<code>locked</code>状态如果是<code>true</code>，那么则说明前一线程要么拿到了锁，要么也处于自旋等待状态，所以自己也要自旋等待。而尾指针<code>tailNode</code>总是指向最后一个线程的<code>CLHNode</code>节点。</p><h3 id="CLH锁的释放锁过程"><a href="#CLH锁的释放锁过程" class="headerlink" title="CLH锁的释放锁过程"></a>CLH锁的释放锁过程</h3><p>前面用图解结合代码说明了CLH锁的加锁过程，那么，CLH锁的释放锁的过程又是怎样的呢？同样，我们先贴下释放锁的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CLHLock.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的当前节点</span></span><br><span class="line">    CLHNode node = curNode.get();</span><br><span class="line">    <span class="comment">// 进行解锁操作</span></span><br><span class="line">    <span class="comment">// 这里将locked至为false，此时执行了lock方法正在自旋等待的后继节点将会获取到锁</span></span><br><span class="line">    <span class="comment">// 【注意】而不是所有正在自旋等待的线程去并发竞争锁</span></span><br><span class="line">    node.locked = <span class="keyword">false</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 释放了锁！！！&quot;</span>);</span><br><span class="line">    <span class="comment">// 小伙伴们可以思考下，下面两句代码的作用是什么？？</span></span><br><span class="line">    CLHNode newCurNode = <span class="keyword">new</span> CLHNode();</span><br><span class="line">    curNode.set(newCurNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【优化】能提高GC效率和节省内存空间，请思考：这是为什么？</span></span><br><span class="line">    <span class="comment">// curNode.set(predNode.get());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到释放CLH锁的过程代码比加锁简单多了，下面同样缕一缕：</p><ol><li>首先从当前线程的线程本地变量中获取出当前<code>CLHNode</code>节点，同时这个<code>CLHNode</code>节点被后面一个线程的<code>preNode</code>变量指向着；</li><li>然后将<code>locked</code>状态置为<code>false</code>即释放了锁；<blockquote><p><em>注意</em>：<code>locked</code>因为被<code>volitile</code>关键字修饰，此时后面自旋等待的线程的局部变量<code>preNode.locked</code>也为<code>false</code>，因此后面自旋等待的线程结束<code>while</code>循环即结束自旋等待，此时也获取到了锁。这一步骤也在异步进行着。</p></blockquote></li><li>然后给当前线程的表示当前节点的线程本地变量重新赋值为一个新的<code>CLHNode</code>。<blockquote><p><em>思考</em>：这一步看上去是多余的，其实并不是。请思考下为什么这么做？我们后续会继续深入讲解。</p></blockquote></li></ol><p>我们还是用一个图来说说明CLH锁释放锁的场景，接着前面四个线程加锁的场景，假如这四个线程加锁后，线程A开始释放锁，此时线程B获取到锁，结束自旋等待，然后线程C和线程D仍然自旋等待，如下图：</p><p><img src="/images/40-5.png" alt="4.3-1"></p><p>以此类推，线程B释放锁的过程也跟上图类似，这里不再赘述。</p><h3 id="同个线程加锁释放锁再次正常获取锁"><a href="#同个线程加锁释放锁再次正常获取锁" class="headerlink" title="同个线程加锁释放锁再次正常获取锁"></a>同个线程加锁释放锁再次正常获取锁</h3><p>在前面<em>4.3小节</em>讲到释放锁<code>unLock</code>方法中有下面两句代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CLHNode newCurNode = <span class="keyword">new</span> CLHNode();</span><br><span class="line">curNode.set(newCurNode);</span><br></pre></td></tr></table></figure><p>这两句代码的作用是什么？这里先直接说结果：若没有这两句代码，若同个线程加锁释放锁后，然后再次执行加锁操作，这个线程就会陷入自旋等待的状态。这是为啥，可能有些下伙伴也没明白，劲越也是搞了蛮久才搞明白，嘿嘿。</p><p>下面我们同样通过一步一图的形式来分析这两句代码的作用。假如有下面这样一个场景：线程A获取到了锁，然后释放锁，然后再次获取锁。</p><p><em>第一步：</em> 线程A执行了lock操作，获取到了锁，如下图：</p><p><img src="/images/40-6.png" alt="4.4-1"></p><p>上图的加锁操作中，线程A的当前<code>CLHNode</code>节点的<code>locked</code>状态被置为<code>true</code>；然后<code>tailNode</code>指针指向了当前线程的当前节点；最后因为前继节点的<code>locked</code>状态为<code>false</code>，不用自旋等待，因此获得了锁。</p><p><em>第二步：</em> 线程A执行了unLock操作，释放了锁，如下图：</p><p><img src="/images/40-7.png" alt="4.4-2"></p><p>上图的释放锁操作中，线程A的当前<code>CLHNode</code>节点的<code>locked</code>状态被置为<code>false</code>，表示释放了锁；然后新建了一个新的<code>CLHNode</code>节点<code>newCurNode</code>，线程A的当前节点线程本地变量值重新指向了<code>newCurNode</code>节点对象。</p><p><em>第三步：</em> 线程A再次执行lock操作，重新获得锁，如下图：</p><p><img src="/images/40-8.png" alt="4.4-3"></p><p>上图的再次获取锁操作中，首先将线程A的当前<code>CLHNode</code>节点的<code>locked</code>状态置为<code>true</code>；然后首先通过<code>tailNode</code>尾指针获取到前继节点即第一，二步中的<code>curNode</code>对象，然后线程A的前继节点线程本地变量的值重新指向了重新指向了<code>curNode</code>对象；然后<code>tailNode</code>尾指针重新指向了新创建的<code>CLHNode</code>节点<code>newCurNode</code>对象。最后因为前继节点的<code>locked</code>状态为<code>false</code>，不用自旋等待，因此获得了锁。</p><blockquote><p><em>扩展：</em> 注意到以上图片的<code>preNode</code>对象此时没有任何引用，所以当下一次会被GC掉。前面是通过每次执行<code>unLock</code>操作都新建一个新的<code>CLHNode</code>节点对象<code>newCurNode</code>，然后让线程A的当前节点线程本地变量值重新指向<code>newCurNode</code>。因此这里完全不用重新创建新的<code>CLHNode</code>节点对象，可以通过<code>curNode.set(predNode.get());</code>这句代码进行优化，提高GC效率和节省内存空间。</p></blockquote><h3 id="考虑同个线程加锁释放锁再次获取锁异常的情况"><a href="#考虑同个线程加锁释放锁再次获取锁异常的情况" class="headerlink" title="考虑同个线程加锁释放锁再次获取锁异常的情况"></a>考虑同个线程加锁释放锁再次获取锁异常的情况</h3><p>现在我们把<code>unLock</code>方法的<code>CLHNode newCurNode = new CLHNode();</code>和<code>curNode.set(newCurNode);</code>这两句代码注释掉，变成了下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CLHLock.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CLHNode node = curNode.get();</span><br><span class="line">    node.locked = <span class="keyword">false</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 释放了锁！！！&quot;</span>);</span><br><span class="line">    <span class="comment">/*CLHNode newCurNode = new CLHNode();</span></span><br><span class="line"><span class="comment">    curNode.set(newCurNode);*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么结果就是线程A通过加锁，释放锁后，再次获取锁时就会陷入自旋等待的状态，这又是为什么呢？我们下面来详细分析。</p><p><em>第一步：</em> 线程A执行了lock操作，获取到了锁，如下图：</p><p><img src="/images/40-9.png" alt="4.5-1"></p><p>上图的加锁操作中，线程A的当前<code>CLHNode</code>节点的<code>locked</code>状态被置为<code>true</code>；然后<code>tailNode</code>指针指向了当前线程的当前节点；最后因为前继节点的<code>locked</code>状态为<code>false</code>，不用自旋等待，因此获得了锁。这一步没有什么异常。</p><p><em>第二步：</em> 线程A执行了unLock操作，释放了锁，如下图：</p><p><img src="/images/40-10.png" alt="4.5-2"></p><p>现在已经把<code>unLock</code>方法的<code>CLHNode newCurNode = new CLHNode();</code>和<code>curNode.set(newCurNode);</code>这两句代码注释掉了，因此上图的变化就是线程A的当前<code>CLHNode</code>节点的<code>locked</code>状态置为<code>false</code>即可。</p><p><em>第三步：</em> 线程A再次执行lock操作，此时会陷入一直自旋等待的状态，如下图：</p><p><img src="/images/40-11.png" alt="4.5-3"></p><p>通过上图对线程A再次获取锁的<code>lock</code>方法的每一句代码进行分析，得知虽然第二步中将线程A的当前<code>CLHNode</code>的<code>locked</code>状态置为<code>false</code>了，但是在第三步线程A再次获取锁的过程中，将当前<code>CLHNode</code>的<code>locked</code>状态又置为<code>true</code>了，且尾指针<code>tailNode</code>指向的依然还是线程A的当前当前<code>CLHNode</code>节点。又因为每次都是将尾指针<code>tailNode</code>指向的<code>CLHNode</code>节点取出来给当前线程的前继<code>CLHNode</code>节点，之后执行<code>while(predNode.locked) &#123;&#125;</code>语句时，此时因为<code>predNode.locked = true</code>，因此线程A就永远自旋等待了。</p><h2 id="测试CLH锁"><a href="#测试CLH锁" class="headerlink" title="测试CLH锁"></a>测试CLH锁</h2><p>下面我们通过一个Demo来测试前面代码实现的CLH锁是否能正常工作，直接上测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CLHLockTest.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试 CLHLocke</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 定义一个静态成员变量 cnt，然后开 10 个线程跑起来，看能是否会有线程安全问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLHLockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CLHLock lock = <span class="keyword">new</span> CLHLock();</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(COUNT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unLock();</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;cnt-----------&gt;&gt;&gt; &quot;</span> + cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面附运行结果截图：</p><p><img src="/images/40-12.png" alt="result"></p><blockquote><p><em>PS：</em> 这里为了截图全面，因此只开了10个线程。经过劲越测试，开100个线程，1000个线程也不会存在线程安全问题。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>好了，前面我们通过多图详细说明了CLH锁的原理与实现，那么我们再对前面的知识进行一次小结：</p><ol><li>首先我们学习了自旋锁和互斥锁的概念与区别；</li><li>然后我们学习了什么是CLH锁以及为什么要学习CLH锁；</li><li>最后我们通过图示+代码实现的方式来学习CLH锁的原理，从而为学习后面的AQS打好坚实的基础。</li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文转载自公众号 “源码笔记”。&lt;/p&gt;
&lt;h2 id=&quot;什么是自旋锁和互斥锁？&quot;&gt;&lt;a href=&quot;#什么是自旋锁和互斥锁？&quot; class=&quot;headerlink&quot; title=&quot;什么是自旋锁和互斥锁？&quot;&gt;&lt;/a&gt;什么是自旋锁和互斥锁？&lt;/h2&gt;&lt;p&gt;由于CLH锁是一种自</summary>
      
    
    
    
    <category term="source code" scheme="http://yangsanity.me/categories/source-code/"/>
    
    
    <category term="AQS" scheme="http://yangsanity.me/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>FutureTask 源码解析</title>
    <link href="http://yangsanity.me/2021/07/27/FutureTask/"/>
    <id>http://yangsanity.me/2021/07/27/FutureTask/</id>
    <published>2021-07-27T01:34:39.000Z</published>
    <updated>2022-05-07T02:09:59.751Z</updated>
    
    <content type="html"><![CDATA[<p><code>FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</code><br><code>RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt;</code></p><p>所以 FutureTask 既是个 Runnable，也是个 Future。因此 FutureTask 可以由 Executor#execute 方法执行，也可以由 ExecutorService#submit 方法提交执行。</p><p>其实在后面线程池源码中可以看到，通过 submit 方法向线程池提交的任务，默认情况下，不管入参是什么类型，最终都是转为最终都是转为 FutureTask。<br>（准确来说，只要是 RunnableFuture 的实现类就可以，但是需要重写 AbstractExecutorService#newTaskFor 方法）</p><p>FutureTask 是可取消的异步计算，可用于包装 Callable 或 Runnable 对象。</p><p>除了作为一个独立的类外，FutureTask 还提供了一些 protected 的功能，这在需要创建自定义任务类的场景下会很有用。</p><h3 id="不同实现"><a href="#不同实现" class="headerlink" title="不同实现"></a>不同实现</h3><p>FutureTask 类一开始有一段 Revision notes 和 Style note 的注释，这是 Doug Lea 大神重构该类做的一些说明。</p><p>因为老版本的实现和当前版本并不一样，老版本是基于 AQS 的方式实现的，新版本是基于 CAS + <a href="/2021/07/23/Treiber-stack/">Treiber stack</a> 来实现的。</p><p><a href="http://hg.openjdk.java.net/jdk6/jdk6/jdk/file/5f4bfda58ef8/src/share/classes/java/util/concurrent/FutureTask.java">jdk6</a> 和 <a href="http://hg.openjdk.java.net/jdk7/jdk7/jdk/file/9b8c96f96a0f/src/share/classes/java/util/concurrent/FutureTask.java">jdk7</a> 是老版本的实现，<a href="http://hg.openjdk.java.net/jdk7u/jdk7u/jdk/file/e9c9327c3d27/src/share/classes/java/util/concurrent/FutureTask.java">jdk7u</a> 开始为当前版本的实现。</p><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>FutureTask 共有 7 种状态，这 7 种状态我自己又将它划分为三类：初始值 / 瞬态值 / 终态值。</p><p><img src="/images/39-1.png" alt="state"></p><p>其可能的状态转换共有 4 种：</p><ol><li><strong><em>NEW -&gt; COMPLETING -&gt; NORMAL</em></strong>（set(V)）</li><li><strong><em>NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</em></strong>（set(Throwable)）</li><li><strong><em>NEW -&gt; CANCELLED</em></strong>（cancel()）</li><li><strong><em>NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</em></strong>（cancel()）</li></ol><p><img src="/images/39-2.png" alt="state-transitions"></p><h3 id="fields"><a href="#fields" class="headerlink" title="fields"></a>fields</h3><p><img src="/images/39-3.png" alt="fields"></p><h3 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h3><p>FutureTask 有两个构造方法</p><ol><li>一个参数：Callable</li></ol><p><img src="/images/39-4.png" alt="constructor-1"></p><ol start="2"><li>两个参数：Runnable + 成功后的返回结果</li></ol><p><img src="/images/39-5.png" alt="constructor-2"></p><p>FutureTask 的构造方法主要干的两件事：给 callable 赋值；将初始状态置为 NEW。</p><p>从 <a href="#fields">fields</a> 可以看出，FutureTask 内部有个 Callable，但是没有 Runnable，两个参数的构造方法传的参数为 Runnable，那底层势必是要将 Runnable 转为 Callable，而 Executors.callable 方法就是干这个事的。</p><p>怎么做的呢？其实就是通过适配器模式，底层最终返回了 <a href="#Executors.RunnableAdapter">Executors.RunnableAdapter</a> 对象。</p><p><img src="/images/39-6.png" alt="Executors.callable"></p><p>从这里可以看到，<strong>FutureTask 最大的作用就是统一了 Runnable 和 Callable，更方便使用。</strong></p><h3 id="WaitNode"><a href="#WaitNode" class="headerlink" title="WaitNode"></a>WaitNode</h3><p>前文说，新版是基于 CAS + Treiber stack 实现的，WaitNode 类就是 Treiber stack 中的元素。</p><p>该类的作用是，封装等待线程（调用 get 方法检索结果时在 awaitDone 方法中阻塞），使其排队，其形式是个单向链表。</p><p><img src="/images/39-7.png" alt="WaitNode"></p><h3 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h3><p>cancel 方法是 Future 接口中的方法，尝试取消正在执行的任务。</p><p>cancel 方法执行逻辑：</p><ol><li>当 state 不为 NEW 时，直接返回 false，表示无法取消该任务；否则，通过 CAS 算法将 state 由 NEW 变为 INTERRUPTING（瞬态值，当 mayInterruptIfRunning 为 true） 或 CANCELLED（终态值，当 mayInterruptIfRunning 为 false），如果这一步失败，说明在执行该操作时其他线程改变了 state，直接返回 false，表示无法取消该任务</li><li>如果 mayInterruptIfRunning 为 true，则调用 interrupt() 方法打断运行当前任务的线程，打断后，将 state 设置为 INTERRUPTED（终态值）</li><li>以上都执行完成后，删除并唤醒所有在 Treiber stack 中排队的等待线程去拿结果。不过此时去拿结果，必然会抛出 CancellationException 或 ExecutionException（report 方法）</li></ol><p><img src="/images/39-8.png" alt="cancel"></p><p>finishCompletion 方法中会调用一个扩展方法 done()，默认实现为空。</p><p><img src="/images/39-9.png" alt="finishCompletion"></p><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>run 方法是 RunnableFuture 接口中的方法。</p><p>run 方法执行逻辑：</p><ol><li>当 state 不为 NEW 时，直接返回；否则，通过 CAS 算法将 runner 由 null 赋值为 currentThread，如果这一步失败，说明在执行该操作时其他线程已经设置了 runner，直接返回</li><li>调用执行 Callable#call()，获取结果。如果正常执行结束，将 result 赋值给 outcome；如果执行过程中抛出异常，将 Throwable 赋值给 outcome</li><li>执行完成后，将 runner 置为 null。还有一个不容易想到的小细节，就是如果此时有别的线程调用了 cancel(true) 方法，当前线程正处于 INTERRUPTING 状态时，我们应该等待该状态由 INTERRUPTING 变为 INTERRUPTED，到达一个终态值</li></ol><p><img src="/images/39-10.png" alt="run"></p><p><img src="/images/39-11.png" alt="handlePossibleCancellationInterrupt"></p><h3 id="runAndReset"><a href="#runAndReset" class="headerlink" title="runAndReset"></a>runAndReset</h3><p>runAndReset 和 run 方法的实现逻辑差不多，唯一的区别就是，该方法不设置结果，并在执行成功后将状态重置为 NEW。</p><p>这是专为本质上执行多次的任务而设计的。ScheduledThreadPoolExecutor 中就用到了该方法。</p><p><img src="/images/39-12.png" alt="runAndReset"></p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>将正常执行结束的结果 result 赋值给 outcome。</p><p>set 方法执行逻辑：</p><ol><li>将 state 由 NEW 变为 COMPLETING（瞬态值）</li><li>给 outcome 赋值</li><li>将 state 由 COMPLETING 变为 NORMAL（终态值，和 setException 唯一不同的地方）</li><li>删除并唤醒所有在 Treiber stack 中排队的等待线程去拿结果</li></ol><p><img src="/images/39-13.png" alt="set"></p><h3 id="setException"><a href="#setException" class="headerlink" title="setException"></a>setException</h3><p>将执行过程中抛出的异常 Throwable 赋值给 outcome。</p><p>setException 方法执行逻辑：</p><ol><li>将 state 由 NEW 变为 COMPLETING（瞬态值）</li><li>给 outcome 赋值</li><li>将 state 由 COMPLETING 变为 EXCEPTIONAL（终态值，和 set 唯一不同的地方）</li><li>删除并唤醒所有在 Treiber stack 中排队的等待线程去拿结果</li></ol><p><img src="/images/39-14.png" alt="setException"></p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><h4 id="无参"><a href="#无参" class="headerlink" title="无参"></a>无参</h4><p>无参的 get 方法是 Future 接口中的方法，阻塞等待直到计算完成，然后检索其结果。</p><p>无参 get 方法执行逻辑：</p><ol><li>如果当前 state 是 NEW 或 COMPLETING 时，说明任务在执行中或在给 outcome 赋值中，则调用 awaitDone 方法阻塞等待</li><li>任务执行完成并给 outcome 赋值后，返回结果或抛出的异常</li></ol><p><img src="/images/39-15.png" alt="get-1"></p><h4 id="两个参数"><a href="#两个参数" class="headerlink" title="两个参数"></a>两个参数</h4><p>两个参数的 get 方法是 Future 接口中的方法，最多阻塞等待给定的计算完成时间，然后检索其结果（如果计算完成）。</p><p>两个参数的 get 方法执行逻辑：</p><ol><li>如果当前 state 是 NEW 或 COMPLETING 时，说明任务在执行中或在给 outcome 赋值中，则调用 awaitDone 方法阻塞等待给定时间</li><li>如果任务经过阻塞等待给定时间后状态仍为 NEW 或 COMPLETING，则抛出超时异常 TimeoutException；否则，返回结果或抛出的异常</li></ol><p><img src="/images/39-16.png" alt="get-2"></p><h3 id="report"><a href="#report" class="headerlink" title="report"></a>report</h3><p>根据状态返回结果或抛出异常。</p><p><img src="/images/39-17.png" alt="report"></p><h3 id="awaitDone"><a href="#awaitDone" class="headerlink" title="awaitDone"></a>awaitDone</h3><p>该方法支持一直阻塞等待（timed 为 false）或阻塞等待给定时间（timed 为 true）。</p><p>该方法里填补前文 Treiber stack 中埋的坑：</p><ol><li>入栈过程在 awaitDone 方法中</li><li>出栈过程在 removeWaiter 方法中</li></ol><p><img src="/images/39-18.png" alt="awaitDone"></p><p><img src="/images/39-19.png" alt="removeWaiter"></p><h3 id="isCancelled"><a href="#isCancelled" class="headerlink" title="isCancelled"></a>isCancelled</h3><p>isCancelled 方法是 Future 接口中的方法，任务是否被取消。</p><p><img src="/images/39-20.png" alt="isCancelled"></p><h3 id="isDone"><a href="#isDone" class="headerlink" title="isDone"></a>isDone</h3><p>isDone 方法是 Future 接口中的方法，任务是否完成。</p><p><img src="/images/39-21.png" alt="isDone"></p><h3 id="protected-methods"><a href="#protected-methods" class="headerlink" title="protected methods"></a>protected methods</h3><h4 id="done"><a href="#done" class="headerlink" title="done"></a>done</h4><p>扩展方法，finishCompletion 方法中调用，默认实现为空，子类可以重写此方法来做回调或记录。</p><p><img src="/images/39-22.png" alt="done"></p><h4 id="other-protected-methods"><a href="#other-protected-methods" class="headerlink" title="other protected methods"></a>other protected methods</h4><p>set / setException / runAndReset 前文均已介绍。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;FutureTask&amp;lt;V&amp;gt; implements RunnableFuture&amp;lt;V&amp;gt;&lt;/code&gt;&lt;br&gt;&lt;code&gt;RunnableFuture&amp;lt;V&amp;gt; extends Runnable, Future&amp;lt;V&amp;gt;&lt;/c</summary>
      
    
    
    
    <category term="source code" scheme="http://yangsanity.me/categories/source-code/"/>
    
    
    <category term="jdk source code" scheme="http://yangsanity.me/tags/jdk-source-code/"/>
    
  </entry>
  
  <entry>
    <title>FutureTask 相关接口源码解析</title>
    <link href="http://yangsanity.me/2021/07/26/FutureTask-pre/"/>
    <id>http://yangsanity.me/2021/07/26/FutureTask-pre/</id>
    <published>2021-07-25T16:33:20.000Z</published>
    <updated>2022-05-07T02:09:59.751Z</updated>
    
    <content type="html"><![CDATA[<p>本文重点分析 FutureTask 相关的所有接口和类，为后面 FutureTask 源码解析做个准备。</p><p>本文涉及到的接口：Callable / Runnable / Future / RunnableFuture<br>本文涉及到的类：Executors.RunnableAdapter</p><h2 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h2><p>Runnable 接口定义了一个无参无返回值的 run 方法。如果某个类的实例计划由一个线程来执行，则可以去实现 Runnable 接口。</p><p>Runnable 接口的设计，是为了给希望在活动状态执行代码逻辑的对象提供通用协议。例如，Thread 类实现了 Runnable。处于活动状态仅意味着线程已启动且尚未停止。</p><p>Runnable 接口提供了使类处于活动状态而不用作为 Thread 子类的方法。通过实例化 Thread 实例并将自身作为 target 传入，实现 Runnable 的类可以在不继承 Thread 的情况下运行（see <a href="/2021/07/20/Thread/#%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3%E5%B9%B6%E5%AE%9E%E7%8E%B0-run-%E6%96%B9%E6%B3%95">Thread 源码解析-实现 Runnable 接口</a>）。</p><p>大多数情况下，如果只需要重写 run() 方法而不是其他 Thread 方法，就应该使用 Runnable 接口。</p><p><img src="/images/38-1.png" alt="Runnable"></p><h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>Callable 接口定义了一个无参有返回值的 call 方法。</p><p>Callable 接口类似于 Runnable 接口，因为两者都是为实例可以由另一个线程执行的类而设计。两者的区别是：Callable 可以返回任务的计算结果或任务运行时抛出的异常。</p><p><img src="/images/38-2.png" alt="Callable"></p><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>Future 表示异步计算的结果。提供了 5 个管理任务的方法。只能在计算完成后通过 get 方法检索结果，该方法必要时会阻塞直到任务完成。</p><p>如果想使用 Future 但不提供可用结果，可以声明为 Future&lt;?&gt; 并返回 null 作为底层任务结果。</p><p>看下 Future 提供的 5 个方法：</p><h3 id="cancel-boolean-mayInterruptIfRunning"><a href="#cancel-boolean-mayInterruptIfRunning" class="headerlink" title="cancel(boolean mayInterruptIfRunning);"></a>cancel(boolean mayInterruptIfRunning);</h3><p>mayInterruptIfRunning 参数决定在取消任务时是否应该中断执行此任务的线程来尝试停止该任务</p><p><img src="/images/38-3.png" alt="cancel"></p><h3 id="isCancelled"><a href="#isCancelled" class="headerlink" title="isCancelled();"></a>isCancelled();</h3><p>任务是否被取消。</p><p><img src="/images/38-4.png" alt="isCancelled"></p><h3 id="isDone"><a href="#isDone" class="headerlink" title="isDone();"></a>isDone();</h3><p>任务是否完成。</p><p><img src="/images/38-5.png" alt="isDone"></p><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>等待计算完成，然后检索其结果。</p><p><img src="/images/38-6.png" alt="get-1"></p><h3 id="get-long-timeout-TimeUnit-unit"><a href="#get-long-timeout-TimeUnit-unit" class="headerlink" title="get(long timeout, TimeUnit unit)"></a>get(long timeout, TimeUnit unit)</h3><p>等待给定的计算完成时间，然后检索其结果（如果计算完成）。</p><p><img src="/images/38-7.png" alt="get-2"></p><h2 id="RunnableFuture"><a href="#RunnableFuture" class="headerlink" title="RunnableFuture"></a>RunnableFuture</h2><p><code>RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt;</code></p><p>RunnableFuture 接口可以让 Future 对 Runnable 进行管理。</p><p><img src="/images/38-8.png" alt="RunnableFuture"></p><h2 id="Executors-RunnableAdapter"><a href="#Executors-RunnableAdapter" class="headerlink" title="Executors.RunnableAdapter"></a>Executors.RunnableAdapter</h2><p><code>RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt;</code></p><p>典型的适配器模式，将 Runnable 适配为 Callable：RunnableAdapter 实现 Callable 接口，接着在 Callable 的 call 方法里面调用 Runnable 的 run 方法。</p><p><img src="/images/38-9.png" alt="Executors.RunnableAdapter"></p><h2 id="boring-question"><a href="#boring-question" class="headerlink" title="boring question"></a>boring question</h2><h3 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h3><p>为什么 RunnableFuture extends Runnable，但是 RunnableFuture 里还定义了一个 run() 方法？</p><p>真有人讨论这个问题：<br><a href="https://stackoverflow.com/questions/25092787/why-does-java-util-concurrent-runnablefuture-have-a-run-method">https://stackoverflow.com/questions/25092787/why-does-java-util-concurrent-runnablefuture-have-a-run-method</a></p><p>大意是，从理论上来讲，确实没有什么必要（no technical significance），但是这么做，可以便于文档展示（specific JavaDoc to it）。</p><h3 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h3><p>为什么 Runnable 里的 run() 方法是 public abstract 的？</p><p>也真有人讨论这个问题：<br><a href="https://stackoverflow.com/questions/3289767/why-run-method-defined-with-abstract-keyword-in-runnable-interface">https://stackoverflow.com/questions/3289767/why-run-method-defined-with-abstract-keyword-in-runnable-interface</a></p><p>大意是，其实这种接口声明风格是不好的，这么做，也许是历史遗留，或者是作者的即兴创作。</p><p><strong>其实这两个问题并没有标准答案，只是我看源码的时候突然想到的，就像生活，有趣且无聊。。</strong></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文重点分析 FutureTask 相关的所有接口和类，为后面 FutureTask 源码解析做个准备。&lt;/p&gt;
&lt;p&gt;本文涉及到的接口：Callable / Runnable / Future / RunnableFuture&lt;br&gt;本文涉及到的类：Executors.R</summary>
      
    
    
    
    <category term="source code" scheme="http://yangsanity.me/categories/source-code/"/>
    
    
    <category term="jdk source code" scheme="http://yangsanity.me/tags/jdk-source-code/"/>
    
  </entry>
  
  <entry>
    <title>Treiber stack</title>
    <link href="http://yangsanity.me/2021/07/23/Treiber-stack/"/>
    <id>http://yangsanity.me/2021/07/23/Treiber-stack/</id>
    <published>2021-07-23T15:48:54.000Z</published>
    <updated>2022-05-07T02:09:59.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><a href="https://en.wikipedia.org/wiki/Treiber_stack">Treiber stack</a> 是线程安全的，基于 CAS 的无锁并发栈。由 R. Kent Treiber 于 1986 年首次在文章 “Systems Programming: Coping with Parallelism” 中发表。</p><h2 id="基本原理："><a href="#基本原理：" class="headerlink" title="基本原理："></a>基本原理：</h2><ol><li><p>入栈时，通过 CAS 算法，将当前栈顶元素（old head）放在新元素之后以创建 new head 来完成</p></li><li><p>出栈时，在返回元素之前，必须检查自该操作开始以来，是否有另一个线程往栈中添加了新元素</p></li></ol><h2 id="Java-example"><a href="#Java-example" class="headerlink" title="Java example"></a>Java example</h2><p>用一个例子就能很容易看明白。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ConcurrentStack</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Nonblocking stack using Treiber&#x27;s algorithm</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Brian Goetz and Tim Peierls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentStack</span> &lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    AtomicReference&lt;Node&lt;E&gt;&gt; top = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; newHead = <span class="keyword">new</span> Node&lt;&gt;(item);</span><br><span class="line">        Node&lt;E&gt; oldHead;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            oldHead = top.get();</span><br><span class="line">            newHead.next = oldHead;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!top.compareAndSet(oldHead, newHead));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; oldHead;</span><br><span class="line">        Node&lt;E&gt; newHead;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            oldHead = top.get();</span><br><span class="line">            <span class="keyword">if</span> (oldHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            newHead = oldHead.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!top.compareAndSet(oldHead, newHead));</span><br><span class="line">        <span class="keyword">return</span> oldHead.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> E item;</span><br><span class="line">        <span class="keyword">public</span> Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="real-case"><a href="#real-case" class="headerlink" title="real case"></a>real case</h2><h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><p>在限流框架 Hystrix 中就使用到了 Treiber stack。其主要实现和上面的 demo 差不多。</p><p>源码位置：com.netflix.hystrix.Hystrix.ConcurrentStack</p><p><img src="/images/37-1.png" alt="Hystrix-ConcurrentStack"></p><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>FutureTask 用到了 Treiber stack，但是是将其作为了简单链表来使用，使调用 get() 方法来检索结果的等待线程排队，并不是像上面的那样实现。</p><p>先挖个坑，后面 FutureTask 的文章会分析其入栈和出栈过程。</p><p>源码位置：java.util.concurrent.FutureTask.WaitNode</p><p><img src="/images/37-2.png" alt="FutureTask-WaitNode"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.</summary>
      
    
    
    
    <category term="algorithm" scheme="http://yangsanity.me/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Thread 源码解析</title>
    <link href="http://yangsanity.me/2021/07/20/Thread/"/>
    <id>http://yangsanity.me/2021/07/20/Thread/</id>
    <published>2021-07-20T03:34:18.000Z</published>
    <updated>2022-05-07T02:09:59.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>每个线程可以被标记为守护线程，当创建新线程的线程是守护线程时，新线程也是守护线程（初始化时，see <a href="#init">init</a>），默认为非守护线程。与之对应的是用户线程。</p><p><img src="/images/36-1.png" alt="daemon"></p><p>守护线程的优先级很低，当 JVM 退出时，不会关心是否还存在守护线程。即使还存在守护线程，JVM 仍会退出。而用户线程如果还在运行，会阻止 JVM 进程退出。</p><p>当 JVM 启动时，通常会有一个非守护线程（通常是类的 main 方法）。当发生以下任一情况时 JVM 才会停止执行：</p><ol><li>Runtime 类的 exit 方法被调用（即终止当前运行的 Java 虚拟机），且安全管理器已允许退出操作的发生</li><li>所有不是守护线程的线程都已经死亡（调用 run 方法后返回 或 抛出异常）</li></ol><p>有一个注意的点是，如果要调用 setDaemon 设置守护线程，必须在线程启动之前调用此方法，否则会抛出 IllegalThreadStateException。</p><p><img src="/images/36-2.png" alt="setDaemon"></p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ol><li><p>垃圾回收线程</p></li><li><p>一些监控工具<br>当 JVM 需要退出时无需关注监控是否正在运行，直接退出不会对业务产生任何影响。</p></li></ol><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>每个线程都有一个优先级，优先级高的线程优先于优先级低的线程执行。当创建一个新的 Thread 对象时，新线程的优先级最初设置为与创建线程的优先级相等（初始化时，see <a href="#init">init</a>）。</p><p>优先级最低 1，最高 10，默认 5。</p><p><img src="/images/36-3.png" alt="priority"></p><p>如果要让新线程的优先级与创建线程的优先级相等，则创建线程的 setPriority 应该在 new Thread() 之前调用；</p><p>如果只想改变新线程的优先级，则新线程的 setPriority 应该在 start() 之前调用。</p><p><img src="/images/36-4.png" alt="setPriority"></p><h2 id="默认名称"><a href="#默认名称" class="headerlink" title="默认名称"></a>默认名称</h2><p>默认名称为（构造方法中，see <a href="#Constructor">Constructor</a>）：”Thread-“ + 一个整数</p><p>该整数计算逻辑为：</p><p><img src="/images/36-5.png" alt="nextThreadNum"></p><p>所以第一个新线程默认名称为：Thread-0。</p><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><h3 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a>NEW</h3><p>尚未启动的线程处于 NEW 状态。</p><h3 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a>RUNNABLE</h3><p>在 JVM 中执行的线程处于 RUNNABLE 状态。但它可能正在等待来自操作系统的其他资源。</p><h3 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a>BLOCKED</h3><p>被阻塞等待监视器锁（monitor lock）的线程处于 BLOCKED 状态。处于阻塞状态的线程正在等待监视器锁进入同步 阻塞/方法 或在调用 Object#wait() 后重入同步 阻塞/方法。</p><h3 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a>WAITING</h3><p>无限期等待另一个线程执行特定操作的线程处于 WAITING 状态。</p><p>调用以下方法之一：</p><ol><li>Object#wait()</li><li>Thread#join()</li><li>LockSupport#park()</li></ol><p>例如，一个线程在一个对象上调用了 Object.wait() 方法，正在等待另一个线程在那个对象上调用 Object.notify() 方法或 Object.notifyAll() 方法；调用 Thread.join() 的线程正在等待指定的线程终止。</p><h3 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING"></a>TIMED_WAITING</h3><p>等待另一个线程执行操作直到指定等待时间的线程处于 TIMED_WAITING 状态。</p><p>调用以下方法之一：</p><ol><li>Thread#sleep</li><li>Object#wait(long)</li><li>Thread#join(long)</li><li>LockSupport#parkNanos</li><li>LockSupport#parkUntil</li></ol><h3 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h3><p>已退出的线程处于 TERMINATED 状态。线程已完成执行。</p><h3 id="状态流转图"><a href="#状态流转图" class="headerlink" title="状态流转图"></a>状态流转图</h3><p><img src="/images/36-6.png" alt="status"></p><h2 id="两种方式创建新线程"><a href="#两种方式创建新线程" class="headerlink" title="两种方式创建新线程"></a>两种方式创建新线程</h2><h3 id="继承-Thread-并重写-run-方法"><a href="#继承-Thread-并重写-run-方法" class="headerlink" title="继承 Thread 并重写 run 方法"></a>继承 Thread 并重写 run 方法</h3><p>demo：计算大于规定值的素数（质数）的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> minPrime;</span><br><span class="line">    PrimeThread(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">        <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrimeThread p = <span class="keyword">new</span> PrimeThread(<span class="number">143</span>);</span><br><span class="line">p.start();</span><br></pre></td></tr></table></figure><h3 id="实现-Runnable-接口并实现-run-方法"><a href="#实现-Runnable-接口并实现-run-方法" class="headerlink" title="实现 Runnable 接口并实现 run 方法"></a>实现 Runnable 接口并实现 run 方法</h3><p>demo（同上）：计算大于规定值的素数（质数）的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> minPrime;</span><br><span class="line">    PrimeRun(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">        <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrimeRun p = <span class="keyword">new</span> PrimeRun(<span class="number">143</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(p).start();</span><br></pre></td></tr></table></figure><h2 id="Other-Source-Code"><a href="#Other-Source-Code" class="headerlink" title="Other Source Code"></a>Other Source Code</h2><h3 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h3><p>一共 9 个构造函数，其中有一个不是 public 的，也就是说，用户可用的构造函数一共有 8 个。</p><p><img src="/images/36-7.png" alt="constructor"></p><p>一个一个看：</p><p><img src="/images/36-8.png" alt="constructor-1"></p><p><img src="/images/36-9.png" alt="constructor-2"></p><p>该构造函数不是 public 的。</p><p><img src="/images/36-10.png" alt="constructor-3"></p><p><img src="/images/36-11.png" alt="constructor-4"></p><p><img src="/images/36-12.png" alt="constructor-5"></p><p><img src="/images/36-13.png" alt="constructor-6"></p><p><img src="/images/36-14.png" alt="constructor-7"></p><p><img src="/images/36-15.png" alt="constructor-8"></p><p><img src="/images/36-16.png" alt="constructor-9"></p><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>从 <a href="#Constructor">Constructor</a> 可以看到，所有的构造函数都是调用了 init 方法。一共有两个 init 方法，其中一个是另一个的重载。</p><p><img src="/images/36-17.png" alt="init-1"></p><p><img src="/images/36-18.png" alt="init-2"></p><p>终于到了完整的 init 逻辑，其中有一些 Java Security 的代码可以不用过多关注。</p><p><img src="/images/36-19.png" alt="init-3"></p><h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p>中间会调用一个 native method start0()。</p><p><img src="/images/36-20.png" alt="start"></p><p>可以看出：如果多次调用 start 方法，会抛出 IllegalThreadStateException。</p><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>run 方法比较简单，其中的 target 是在 <a href="#init">init</a> 方法中赋值的 Runnable（如果有的话），如果 target 为 null 则什么也不做（这也是继承 Thread 后需要重写 run 方法的原因）。</p><p><img src="/images/36-21.png" alt="run"></p><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><p>sleep 有 2 个方法</p><h4 id="一个参数的方法"><a href="#一个参数的方法" class="headerlink" title="一个参数的方法"></a>一个参数的方法</h4><p>是 native method。</p><p><img src="/images/36-22.png" alt="sleep-1"></p><h4 id="两个参数的方法"><a href="#两个参数的方法" class="headerlink" title="两个参数的方法"></a>两个参数的方法</h4><p>根据注释是为了实现纳秒级别的睡眠。</p><p><img src="/images/36-23.png" alt="sleep-2"></p><p>但有意思的是，两个参数的方法在实现上和注释有点不太相符。。</p><p>注释中说，休眠时间 = 毫秒数 + 纳秒数，但其实真实情况是：</p><ol><li>当 nanos 小于 0.5ms时，millis 不变；</li><li>当 nanos 大于等于 0.5ms时，millis 加 1；</li><li>当 nanos 不为 0 且 millis 为 0 时，millis 加 1<br>也就是说该方法并没有实现 ns 级别的睡眠，最小的睡眠时间为 1ms。</li></ol><p>主要代码在这里</p><p><img src="/images/36-24.png" alt="sleep-3"></p><p>所以这个方法存在的意义是什么呢？想不明白，从注释上也没看出来。</p><p>发现 stackoverflow 上也有一些讨论，具体的意义大家还是自行体会吧：<br><a href="https://stackoverflow.com/questions/6553225/whats-the-purpose-of-sleeplong-millis-int-nanos">https://stackoverflow.com/questions/6553225/whats-the-purpose-of-sleeplong-millis-int-nanos</a></p><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>join 有 3 个方法</p><h4 id="无参数的方法"><a href="#无参数的方法" class="headerlink" title="无参数的方法"></a>无参数的方法</h4><p>是为了永远等待。</p><p><img src="/images/36-25.png" alt="join-1"></p><h4 id="两个参数的方法-1"><a href="#两个参数的方法-1" class="headerlink" title="两个参数的方法"></a>两个参数的方法</h4><p>根据注释是为了实现纳秒级别的等待。</p><p>同两个参数的 <a href="#sleep">sleep</a> 方法，该方法也并没有实现 ns 级别的等待，最小的等待时间为 1ms。</p><p><img src="/images/36-26.png" alt="join-2"></p><h4 id="一个参数的方法-1"><a href="#一个参数的方法-1" class="headerlink" title="一个参数的方法"></a>一个参数的方法</h4><p>是真正的实现逻辑。</p><p>实现方式是 while 循环。参数为 0 意味着永远等待。isAlive() / wait(Long) 都是 native method。</p><p><img src="/images/36-27.png" alt="join-3"></p><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>是一个 native method，表示当前线程愿意放弃对 CPU 的使用，可以防止过度使用 CPU。</p><p>但是调度程序可以随意忽略此提示，另外重新竞争时，CPU 也有可能再次选中自己。</p><p><img src="/images/36-28.png" alt="yield"></p><h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><p>常见 API 有三个</p><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4><p>中间会调用一个 native method interrupt0()。</p><p>当调用 Object#wait / Thread#join / Thread#sleep 方法时，如果调用此方法，会抛出 InterruptedException。</p><p>要注意的是，当抛出 InterruptedException 时，线程的中断状态会被清除。</p><p><img src="/images/36-29.png" alt="interrupt"></p><h4 id="isInterrupted"><a href="#isInterrupted" class="headerlink" title="isInterrupted"></a>isInterrupted</h4><p>isInterrupted 有 2 个方法</p><h5 id="无参数的方法-1"><a href="#无参数的方法-1" class="headerlink" title="无参数的方法"></a>无参数的方法</h5><p>是测试此线程是否已被中断。</p><p><img src="/images/36-30.png" alt="isInterrupted-1"></p><h5 id="一个参数的方法-2"><a href="#一个参数的方法-2" class="headerlink" title="一个参数的方法"></a>一个参数的方法</h5><p>是 native method，可以根据传入的参数决定是否重置中断状态。该方法也是 interrupted 的底层实现。</p><p><img src="/images/36-31.png" alt="isInterrupted-2"></p><h4 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted"></a>interrupted</h4><p>底层实现依赖上面 isInterrupted 一个参数的方法。</p><p><img src="/images/36-32.png" alt="interrupted"></p><h3 id="ThreadLocal-amp-InheritableThreadLocal-变量"><a href="#ThreadLocal-amp-InheritableThreadLocal-变量" class="headerlink" title="ThreadLocal &amp; InheritableThreadLocal 变量"></a>ThreadLocal &amp; InheritableThreadLocal 变量</h3><p>这两个变量也必须强行漏个脸。可以看到每个线程维护自己的变量。</p><p><img src="/images/36-33.png" alt="ThreadLocal &amp; InheritableThreadLocal"></p><h3 id="Deprecated-Methods"><a href="#Deprecated-Methods" class="headerlink" title="Deprecated Methods"></a>Deprecated Methods</h3><p>一共 6 个 deprecated methods</p><ol><li>Thread#stop() / Thread#stop(Throwable) / Thread#destroy() / Thread#suspend() / Thread#resume()</li></ol><p>deprecated 原因：<br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html%E3%80%82">https://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html。</a></p><ol start="2"><li>还有一个 native method: Thread#countStackFrames()</li></ol><p>该方法作用主要是：计算线程中的堆栈帧数，而此时线程必须被挂起，否则会抛出 IllegalThreadStateException。</p><p>deprecated 原因：此调用的定义取决于 deprecated method Thread#suspend()。此外，此调用的结果从未明确定义。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;守护线程&quot;&gt;&lt;a href=&quot;#守护线程&quot; class=&quot;headerlink&quot; title=&quot;守护线程&quot;&gt;&lt;/a&gt;守护线程&lt;/h2&gt;&lt;p&gt;每个线程可以被标记为守护线程，当创建新线程的线程是守护线程时，新线程也是守护线程（初始化时，see &lt;a href=&quot;#in</summary>
      
    
    
    
    <category term="source code" scheme="http://yangsanity.me/categories/source-code/"/>
    
    
    <category term="jdk source code" scheme="http://yangsanity.me/tags/jdk-source-code/"/>
    
  </entry>
  
  <entry>
    <title>What is the real Spring IoC container</title>
    <link href="http://yangsanity.me/2021/04/21/What-is-the-real-Spring-IoC-container/"/>
    <id>http://yangsanity.me/2021/04/21/What-is-the-real-Spring-IoC-container/</id>
    <published>2021-04-21T14:04:30.000Z</published>
    <updated>2022-05-07T02:09:59.749Z</updated>
    
    <content type="html"><![CDATA[<p><em>note：本文基于 spring-framework 5.2.2.RELEASE</em></p><p>What is the real Spring IoC container? <code>BeanFactory</code> or <code>ApplicationContext</code>?</p><h2 id="官网描述"><a href="#官网描述" class="headerlink" title="官网描述"></a>官网描述</h2><p>从<a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/spring-framework-reference/core.html#beans-introduction"> Spring 官网 beans-introduction </a>描述中可以得到以下信息：</p><blockquote><ul><li>源码工程中的 <code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 包是 Spring Framework 的 IoC container 基础</li><li><code>BeanFactory</code> 接口提供了一种高级配置机制能够管理任何类型的对象</li><li><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的一个子类，它增加了以下功能：<ul><li>更容易和 Spring AOP 集成</li><li>消息资源处理（用于国际化）</li><li>事件发布</li><li>应用层面特定上下文，例如用于 web 应用的 <code>WebApplicationContext</code></li></ul></li><li>简而言之，<code>BeanFactory</code> 提供了配置框架和基础的功能，而 <code>ApplicationContext</code> 增加了更多企业级特性的功能。<code>ApplicationContext</code> 是 <code>BeanFactory</code> 的一个完整超集</li></ul></blockquote><h3 id="BeanFactory-or-ApplicationContext"><a href="#BeanFactory-or-ApplicationContext" class="headerlink" title="BeanFactory or ApplicationContext?"></a><code>BeanFactory</code> or <code>ApplicationContext</code>?</h3><p><code>BeanFactory</code> 和 <code>ApplicationContext</code> 应该如何选择？</p><p><a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/spring-framework-reference/core.html#beans-beanfactory">Spring 官网 BeanFactory or ApplicationContext </a>中也做了详细的描述。重点是这两句：</p><blockquote><p>You should use an ApplicationContext unless you have a good reason for not doing so<br>（你应该使用 ApplicationContext，除非你有很好的理由不使用它）<br>Because an ApplicationContext includes all the functionality of a BeanFactory, it is generally recommended over a plain BeanFactory<br>（因为 ApplicationContext 包含了 BeanFactory 的所有功能，通常建议使用）</p></blockquote><p>还附了一张关于 Feature Matrix(功能矩阵) 的表来描述 <code>BeanFactory</code> 和 <code>ApplicationContext</code> 接口和实现所提供的功能：</p><table><thead><tr><th align="center">特性</th><th align="center">BeanFactory</th><th align="center">ApplicationContext</th></tr></thead><tbody><tr><td align="center">Bean 实例化/加工(wiring)</td><td align="center">Yes</td><td align="center">Yes</td></tr><tr><td align="center">集成生命周期管理</td><td align="center">No</td><td align="center">Yes</td></tr><tr><td align="center">自动注册 <code>BeanPostProcessor</code></td><td align="center">No</td><td align="center">Yes</td></tr><tr><td align="center">自动注册 <code>BeanFactoryPostProcessor</code></td><td align="center">No</td><td align="center">Yes</td></tr><tr><td align="center">方便 <code>MessageSource</code> 访问（用于国际化）</td><td align="center">No</td><td align="center">Yes</td></tr><tr><td align="center">内置 <code>ApplicationEvent</code> 发布机制</td><td align="center">No</td><td align="center">Yes</td></tr></tbody></table><p>可以看出，官方更推荐使用 <code>ApplicationContext</code>，但这并不代表 <code>BeanFactory</code> 就没有使用场景，只是场景真的比较有限，具体可参考官方文档描述。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="ApplicationContext-Java-Diagrams"><a href="#ApplicationContext-Java-Diagrams" class="headerlink" title="ApplicationContext Java Diagrams"></a>ApplicationContext Java Diagrams</h3><p><img src="/images/35-1.png" alt="ApplicationContext diagrams"></p><p>从图中可以可以反映出：<code>ApplicationContext</code> 自身就是一个 <code>BeanFactory</code> 并且它还拥有其他功能。</p><p>那么，<code>ApplicationContext</code> 是 <code>BeanFactory</code> 的一个完整超集这是如何实现的呢？</p><h3 id="ApplicationContext-internal-BeanFactory"><a href="#ApplicationContext-internal-BeanFactory" class="headerlink" title="ApplicationContext internal BeanFactory"></a>ApplicationContext internal BeanFactory</h3><p><code>ApplicationContext</code> 源码中，getAutowireCapableBeanFactory() 方法注释中有个重要的字眼：<em>internal BeanFactory</em>。</p><p><img src="/images/35-2.png"></p><p>这个字眼是否意味着，虽然 <code>ApplicationContext</code> 是一个 <code>BeanFactory</code>，但是其内部还有一个 BeanFactory？如果真是这样，是否多此一举呢？</p><p>顺着该方法注释提示去 @see ConfigurableApplicationContext#getBeanFactory() 源码，发现该方法注释第一句就解答了疑问：</p><blockquote><p>Return the internal bean factory of this application context. Can be used to access specific functionality of the underlying factory.<br>（返回此应用程序上下文的内部 bean factory。可用于访问基础 factory 的特定功能）</p></blockquote><p><img src="/images/35-3.png"></p><h4 id="How-to-set-internal-BeanFactory"><a href="#How-to-set-internal-BeanFactory" class="headerlink" title="How to set internal BeanFactory"></a>How to set internal BeanFactory</h4><p>这里就有一个新问题，这个 internal BeanFactory 是如何设置进去的？</p><p>按常理来讲，既然有 getBeanFactory() 方法，那应该也有一个 setBeanFactory() 方法用来把 beanFactory set 进去，但是很遗憾，源码中并没有 setBeanFactory() 方法。</p><p>继续查看 getBeanFactory() 的实现，发现有两个类实现了该方法：<code>AbstractRefreshableApplicationContext</code> 和 <code>GenericApplicationContext</code>。</p><p>继续看这两个类的源码会发现，这两个类里都有一个非常重要的内部属性：DefaultListableBeanFactory beanFactory，而 getBeanFactory() 方法返回的  internal BeanFactory 正是这个 beanFactory！</p><p>这种方式有点像代理，通过组合的方式把 <code>BeanFactory</code> 的实现 <code>DefaultListableBeanFactory</code> 组合进来，并不是完全去抽象或继承该类。</p><p>题外：其实这两个类都很重要，Spring 中”著名”的两个类都继承自它们：</p><ul><li><code>ClassPathXmlApplicationContext</code> extends … extends <code>AbstractRefreshableApplicationContext</code></li><li><code>AnnotationConfigApplicationContext</code> extends <code>GenericApplicationContext</code></li></ul><h4 id="应用-internal-BeanFactory"><a href="#应用-internal-BeanFactory" class="headerlink" title="应用 internal BeanFactory"></a>应用 internal BeanFactory</h4><p>可以看下 Spring 里 <code>AbstractApplicationContext</code> 里的各个 getBean() 方法的实现，都是先调用 getBeanFactory() 再调用 getBean()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    assertBeanFactoryActive();</span><br><span class="line">    <span class="keyword">return</span> getBeanFactory().getBean(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>ApplicationContext</code> 其实并不具备依赖查找的能力，都是委托给自己的 internal beanFactory 来实现。</p><p>同时也反映了，<code>BeanFactory</code> 其实是最底层的 IoC 容器，<code>ApplicationContext</code> 是在 <code>BeanFactory</code> 的基础上增加了一些特性。</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>综上，可以说，<code>BeanFactory</code> 含有的能力 <code>ApplicationContext</code> 都有，并且 <code>ApplicationContext</code> 提供了更多的特性。</p><p>再看官网这句话，就豁然开朗了： <strong><code>BeanFactory</code> 提供了配置框架和基础的功能，而 <code>ApplicationContext</code> 增加了更多企业级特性的功能。<code>ApplicationContext</code> 是 <code>BeanFactory </code> 的一个完整超集。</strong></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;note：本文基于 spring-framework 5.2.2.RELEASE&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;What is the real Spring IoC container? &lt;code&gt;BeanFactory&lt;/code&gt; or &lt;code&gt;Applica</summary>
      
    
    
    
    <category term="source code" scheme="http://yangsanity.me/categories/source-code/"/>
    
    <category term="Spring" scheme="http://yangsanity.me/categories/Spring/"/>
    
    
    <category term="spring framework" scheme="http://yangsanity.me/tags/spring-framework/"/>
    
  </entry>
  
  <entry>
    <title>jstack 基本命令</title>
    <link href="http://yangsanity.me/2021/04/12/jstack-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>http://yangsanity.me/2021/04/12/jstack-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</id>
    <published>2021-04-12T13:14:21.000Z</published>
    <updated>2022-05-07T02:09:59.750Z</updated>
    
    <content type="html"><![CDATA[<p>JDK 的 bin 目录下为 Java 开发人员提供了很多实用的小工具，很多场景下都会用到它们，比如：打包、部署、签名、调试、监控、运维等。本文介绍其中一款：</p><p><strong>jstack (Stack Trace for Java)</strong>: Java 堆栈跟踪工具</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>生成虚拟机当前时刻的线程快照(一般称为 threaddump 或者 javacore 文件)。</p><p>线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的通常是<em>定位线程出现长时间停顿的原因</em>，如线程间死锁、死循环、请求外部资源导致的长时间挂起等，都是导致线程长时间停顿的常见原因。</p><p>线程出现停顿时通过 jstack 来查看各个线程的调用堆栈，就可以获知没有响应的线程到底在后台做些什么事情，或者等待着什么资源。</p><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [ option ] vmid</span><br></pre></td></tr></table></figure><h3 id="option"><a href="#option" class="headerlink" title="option"></a>option</h3><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-F</td><td align="center">当正常输出的请求不被响应时，强制输出线程堆栈</td></tr><tr><td align="center">-l</td><td align="center">除堆栈外，显示关于锁的附加信息</td></tr><tr><td align="center">-m</td><td align="center">如果调用到本地方法的话，可以显示 C/C++ 的堆栈</td></tr></tbody></table><h2 id="执行样例"><a href="#执行样例" class="headerlink" title="执行样例"></a>执行样例</h2><h3 id="使用-jstack-查看线程堆栈"><a href="#使用-jstack-查看线程堆栈" class="headerlink" title="使用 jstack 查看线程堆栈"></a>使用 jstack 查看线程堆栈</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstack 5511</span><br></pre></td></tr></table></figure><p><img src="/images/34-1.png"></p><h3 id="统计线程数"><a href="#统计线程数" class="headerlink" title="统计线程数"></a>统计线程数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstack 5511 | grep &#39;java.lang.Thread.State&#39; | wc -l</span><br></pre></td></tr></table></figure><p><img src="/images/34-2.png"></p><h3 id="使用-jstack-定位进程中-cpu-占用最高的线程"><a href="#使用-jstack-定位进程中-cpu-占用最高的线程" class="headerlink" title="使用 jstack 定位进程中 cpu 占用最高的线程"></a>使用 jstack 定位进程中 cpu 占用最高的线程</h3><ol><li>查看 cpu 占用高线程</li></ol><ul><li><p>-H: 指示 top 命令显示单个线程。如果没有该选项，则显示每个进程中的线程总和</p></li><li><p>-p: 后跟进程 ID (process id)，这里为 LVMID</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ top -H -p 5511</span><br></pre></td></tr></table></figure><p><img src="/images/34-3.png"></p><ol start="3"><li>转换线程 ID</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ printf &quot;%x\n&quot; 6072</span><br></pre></td></tr></table></figure><p><img src="/images/34-4.png"></p><ol start="4"><li>定位进程中 cpu 占用最高的线程</li></ol><ul><li><p>-A: 往下展示 x 行信息</p></li><li><p>-B: 往上展示 x 行信息</p></li></ul><p><em>加上 -A 或 -B，可以打印出线程具体的堆栈信息</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstack 5511 | grep 17b8 -A 10</span><br></pre></td></tr></table></figure><p><img src="/images/34-5.png"></p><h4 id="同理检测-cpu-高的原因"><a href="#同理检测-cpu-高的原因" class="headerlink" title="同理检测 cpu 高的原因"></a>同理检测 cpu 高的原因</h4><ul><li><p>使用 top 命令找到 cpu 占用最高的进程</p></li><li><p>查看进程中 cpu 占用最高的线程（同上）寻找原因</p></li></ul><p>reference: <a href="https://man7.org/linux/man-pages/man1/top.1.html">top</a></p><h3 id="使用-jstack-检测死锁"><a href="#使用-jstack-检测死锁" class="headerlink" title="使用 jstack 检测死锁"></a>使用 jstack 检测死锁</h3><ol><li>死锁代码：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeathLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Lock LOCK_1 = <span class="keyword">new</span> ReentrantLock(), LOCK_2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deathLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                LOCK_1.lock();</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                LOCK_2.lock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;death_lock_demo_thread1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                LOCK_2.lock();</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                LOCK_1.lock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;death_lock_demo_thread2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        deathLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>demo 运行后 jps 查询 LVMID 为 33391：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jps -l | grep DeathLockDemo</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 jstack 检测死锁</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstack -l 33391</span><br></pre></td></tr></table></figure><p>关键信息如下：</p><p><img src="/images/34-6.png"><br><img src="/images/34-7.png"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JDK 的 bin 目录下为 Java 开发人员提供了很多实用的小工具，很多场景下都会用到它们，比如：打包、部署、签名、调试、监控、运维等。本文介绍其中一款：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;jstack (Stack Trace for Java)&lt;/strong&gt;: Ja</summary>
      
    
    
    
    <category term="JVM" scheme="http://yangsanity.me/categories/JVM/"/>
    
    
    <category term="JVM Tool" scheme="http://yangsanity.me/tags/JVM-Tool/"/>
    
  </entry>
  
  <entry>
    <title>jhat 基本命令</title>
    <link href="http://yangsanity.me/2021/04/05/jhat-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>http://yangsanity.me/2021/04/05/jhat-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</id>
    <published>2021-04-05T01:00:28.000Z</published>
    <updated>2022-05-07T02:09:59.749Z</updated>
    
    <content type="html"><![CDATA[<p>JDK 的 bin 目录下为 Java 开发人员提供了很多实用的小工具，很多场景下都会用到它们，比如：打包、部署、签名、调试、监控、运维等。本文介绍其中一款：</p><p><strong>jhat (JVM Heap Analysis Tool)</strong>: 虚拟机堆转储快照分析工具</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>与 jmap 搭配使用，分析 jmap 生成的堆转储快照。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>jhat 内置了一个微型的 HTTP/Web 服务器，生成堆转储快照的分析结果后，可以在浏览器中查看。</p><h3 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h3><p>在实际工作中，多数人是不会直接使用 jhat 命令来分析堆转储快照文件的，主要原因是：</p><ul><li><p>一般不会在部署应用程序的服务器上直接分析堆转储快照，即使可以这样做，也会尽量将堆转储快照文件复制到其他机器上进行分析，因为分析工作是一个耗时而且极为耗费硬件资源的过程（加载 dump 快照文件需要比生成 dump 更大的内存）。</p><ul><li>（话说回来，既然都要在其他机器上进行，还有必要再受命令行工具的限制吗？）</li></ul></li><li><p> jhat 的分析功能相对来说比较简陋，VisualVM 或 JProfiler 等工具也可以分析堆转储快照文件，而且能提供比 jhat 更强大专业的分析功能。</p></li></ul><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhat &lt;filename&gt;</span><br></pre></td></tr></table></figure><h2 id="使用-jhat-分析-dump-文件"><a href="#使用-jhat-分析-dump-文件" class="headerlink" title="使用 jhat 分析 dump 文件"></a>使用 jhat 分析 dump 文件</h2><p>以 <a href="https://github.com/alibaba/arthas/blob/master/README_CN.md">arthas 官网</a>提供的 arthas-demo.jar 为例。</p><ol><li>在本地启动 arthas-demo.jar，并将日志输出到指定文件：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nohup java -jar arthas-demo.jar &gt; demo.log &amp;</span><br></pre></td></tr></table></figure><ol start="2"><li>jps 查询 LVMID (进程 ID) 为 65034：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jps -l | grep arthas-demo.jar</span><br></pre></td></tr></table></figure><ol start="3"><li>生成 Java 堆转储快照。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -dump:format&#x3D;b,file&#x3D;demo.bin 65034</span><br></pre></td></tr></table></figure><ol start="4"><li>jhat 分析</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jhat demo.bin</span><br></pre></td></tr></table></figure><p><img src="/images/33-1.png"></p><p>“Server is ready” 后，在浏览器中输入 <a href="http://localhost:7000/">http://localhost:7000/</a> 可以查看分析结果。</p><p><img src="/images/33-2.png"></p><p>分析结果默认以包为单位进行分组显示，分析内存泄漏问题主要会使用到<em>上图中的 “Show heap histogram”(与 <code>jmap-histo</code> 功能一样)</em> 与 <em>OQL 页签的功能（上图中的 “Execute Object Query Language (OQL) query”）</em>，前者可以找到内存中总容量最大的对象，后者是标准的对象查询语言，使用类似 SQL 的语法对内存中的对象进行查询统计。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JDK 的 bin 目录下为 Java 开发人员提供了很多实用的小工具，很多场景下都会用到它们，比如：打包、部署、签名、调试、监控、运维等。本文介绍其中一款：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;jhat (JVM Heap Analysis Tool)&lt;/strong&gt;: 虚拟</summary>
      
    
    
    
    <category term="JVM" scheme="http://yangsanity.me/categories/JVM/"/>
    
    
    <category term="JVM Tool" scheme="http://yangsanity.me/tags/JVM-Tool/"/>
    
  </entry>
  
  <entry>
    <title>jmap 基本命令</title>
    <link href="http://yangsanity.me/2021/04/04/jmap-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>http://yangsanity.me/2021/04/04/jmap-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</id>
    <published>2021-04-04T01:00:53.000Z</published>
    <updated>2022-05-07T02:09:59.750Z</updated>
    
    <content type="html"><![CDATA[<p>JDK 的 bin 目录下为 Java 开发人员提供了很多实用的小工具，很多场景下都会用到它们，比如：打包、部署、签名、调试、监控、运维等。本文介绍其中一款：</p><p><strong>jmap (Memory Map for Java)</strong>: Java 内存映像工具</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li><p>生成堆转储快照 (一般称为 heapdump 或 dump 文件)。</p></li><li><p>查询 finalize 执行队列、Java 堆和方法区的详细信息，如空间使用率、当前用的是哪种收集器等。</p></li></ul><h3 id="获取-Java-堆转储快照的其他方法"><a href="#获取-Java-堆转储快照的其他方法" class="headerlink" title="获取 Java 堆转储快照的其他方法"></a>获取 Java 堆转储快照的其他方法</h3><h4 id="XX-HeapDumpOnOutOfMemoryError"><a href="#XX-HeapDumpOnOutOfMemoryError" class="headerlink" title="- XX:+HeapDumpOnOutOfMemoryError"></a>- XX:+HeapDumpOnOutOfMemoryError</h4><p>让虚拟机在内存溢出异常出现之后自动生成堆转储快照文件。</p><h4 id="XX-HeapDumpOnCtrlBreak"><a href="#XX-HeapDumpOnCtrlBreak" class="headerlink" title="-XX:+HeapDumpOnCtrlBreak"></a>-XX:+HeapDumpOnCtrlBreak</h4><p>可以使用 [Ctrl] + [Break] 键让虚拟机生成堆转储快照文件。</p><h4 id="Kill-3"><a href="#Kill-3" class="headerlink" title="Kill -3"></a>Kill -3</h4><p>发送进程退出信号“恐吓”一下虚拟机，也能顺利拿到堆转储快照。</p><h5 id="Kill-3-使用示例"><a href="#Kill-3-使用示例" class="headerlink" title="Kill -3 使用示例"></a>Kill -3 使用示例</h5><p>以 <a href="https://github.com/alibaba/arthas/blob/master/README_CN.md">arthas 官网</a>提供的 arthas-demo.jar 为例。</p><ol><li>在本地启动 arthas-demo.jar，并将日志输出到指定文件：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nohup java -jar arthas-demo.jar &gt; demo.log &amp;</span><br></pre></td></tr></table></figure><ol start="2"><li>jps 查询 LVMID (进程 ID) 为 54776：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jps -l | grep arthas-demo.jar</span><br></pre></td></tr></table></figure><ol start="3"><li>执行 Kill -3：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ Kill -3 54776</span><br></pre></td></tr></table></figure><ol start="4"><li>查看 demo.log 文件内容</li></ol><p><img src="/images/32-1.png"></p><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [ option ] vmid</span><br></pre></td></tr></table></figure><h3 id="options"><a href="#options" class="headerlink" title="options"></a>options</h3><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-dump</td><td align="center">生成 Java 堆转储快照。格式为：-dump:[live, ]format=b,file=<code>&lt;filename&gt;</code>，其中 live 子参数说明是否只 dump 出存活的对象</td></tr><tr><td align="center">-finalizerinfo</td><td align="center">显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象。只在 Linux/Solaris 平台下有效</td></tr><tr><td align="center">-heap</td><td align="center">显示 Java 堆详细信息，如使用哪种回收器、参数配置、分代状况等。只在 Linux/Solaris 平台下有效</td></tr><tr><td align="center">-histo</td><td align="center">(histogram) 显示堆中对象统计信息，包括类、实例数量、合计容量</td></tr><tr><td align="center">-permstat(x)</td><td align="center">以 ClassLoader 为统计口径显示永久代内存状态。只在 Linux/Solaris 平台下有效 (高版本已移除)</td></tr><tr><td align="center">-F</td><td align="center">当虚拟机进程对 -dump 选项没有响应时，可使用这个选项强制生成dump快照。只在 Linux/Solaris 平台下有效</td></tr><tr><td align="center">-clstats</td><td align="center">输出 ClassLoader 统计</td></tr></tbody></table><h2 id="执行样例"><a href="#执行样例" class="headerlink" title="执行样例"></a>执行样例</h2><h3 id="dump"><a href="#dump" class="headerlink" title="-dump"></a>-dump</h3><p>生成 Java 堆转储快照。格式为：-dump:[live, ]format=b,file=<code>&lt;filename&gt;</code>，其中 live 子参数说明是否只 dump 出存活的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -dump:format&#x3D;b,file&#x3D;resourceManager.bin 5511</span><br></pre></td></tr></table></figure><p><img src="/images/32-2.png"></p><h3 id="finalizerinfo"><a href="#finalizerinfo" class="headerlink" title="-finalizerinfo"></a>-finalizerinfo</h3><p>显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象。只在 Linux/Solaris 平台下有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -finalizerinfo 5511</span><br></pre></td></tr></table></figure><p><img src="/images/32-3.png"></p><h3 id="heap"><a href="#heap" class="headerlink" title="-heap"></a>-heap</h3><p>显示 Java 堆详细信息，如使用哪种回收器、参数配置、分代状况等。只在 Linux/Solaris 平台下有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -heap 5511</span><br></pre></td></tr></table></figure><p><img src="/images/32-4.png"></p><h3 id="histo"><a href="#histo" class="headerlink" title="-histo"></a>-histo</h3><p>(histogram) 显示堆中对象统计信息，包括类（class name）、实例数量（instances）、合计容量（bytes）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -histo 5511</span><br></pre></td></tr></table></figure><p><img src="/images/32-5.png"></p><h3 id="clstats"><a href="#clstats" class="headerlink" title="-clstats"></a>-clstats</h3><p>输出 ClassLoader 统计。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -clstats 5511</span><br></pre></td></tr></table></figure><p><img src="/images/32-6.png"></p><h2 id="分析堆转储快照"><a href="#分析堆转储快照" class="headerlink" title="分析堆转储快照"></a>分析堆转储快照</h2><p>堆转储快照直接看看不懂，如何来分析 jmap 生成的堆转储快照？</p><p>可以用 JVM 提供的另一款小工具 - jhat，但其实这个一般会比较少用，大多数情况是用 VisualVM 或 JProfiler 等工具，因为这些工具功能更强大。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JDK 的 bin 目录下为 Java 开发人员提供了很多实用的小工具，很多场景下都会用到它们，比如：打包、部署、签名、调试、监控、运维等。本文介绍其中一款：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;jmap (Memory Map for Java)&lt;/strong&gt;: Java </summary>
      
    
    
    
    <category term="JVM" scheme="http://yangsanity.me/categories/JVM/"/>
    
    
    <category term="JVM Tool" scheme="http://yangsanity.me/tags/JVM-Tool/"/>
    
  </entry>
  
  <entry>
    <title>jinfo 基本命令</title>
    <link href="http://yangsanity.me/2021/04/03/jinfo-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>http://yangsanity.me/2021/04/03/jinfo-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</id>
    <published>2021-04-03T01:00:30.000Z</published>
    <updated>2022-05-07T02:09:59.750Z</updated>
    
    <content type="html"><![CDATA[<p>JDK 的 bin 目录下为 Java 开发人员提供了很多实用的小工具，很多场景下都会用到它们，比如：打包、部署、签名、调试、监控、运维等。本文介绍其中一款：</p><p><strong>jinfo (Configuration Info for Java)</strong>: Java 配置信息工具</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>实时查看和调整虚拟机各项参数：</p><ul><li><p>使用 <code>jps -v</code> 命令可以查看虚拟机启动时显式指定的参数列表，而使用 <code>jinfo -flag</code> 命令可以查询未被显式指定的参数的系统默认值。</p><ul><li>对于 JDK 6 及以上版本，还可以使用 <code>java- XX:+PrintFlagsFinal</code> 查看参数默认值(命令: <code>$ java -XX:+PrintFlagsFinal -version</code>)。</li></ul></li><li><p>使用 <code>jinfo -sysprops</code> 命令可以打印虚拟机进程的 System.getProperties() 的内容。JDK 6 之后，该命令除了提供信息查询功能，还加入了在运行期修改部分参数值的能力(使用 <code>-flag[+/-]name 或 -flag name=value</code> 在运行期修改一部分运行期可写的虚拟机参数值)。</p></li></ul><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jinfo [ option ] pid</span><br></pre></td></tr></table></figure><h3 id="option"><a href="#option" class="headerlink" title="option"></a>option</h3><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>-flag &lt;name&gt;</code></td><td align="center">打印虚拟机标记参数的值</td></tr><tr><td align="center"><code>-flag [+/-]&lt;name&gt;</code></td><td align="center">开启或关闭虚拟机标记参数</td></tr><tr><td align="center"><code>-flag &lt;name&gt;=&lt;value&gt;</code></td><td align="center">设置虚拟机标记参数</td></tr><tr><td align="center">-flags</td><td align="center">输出虚拟机参数</td></tr><tr><td align="center">-sysprops</td><td align="center">输出 Java 系统属性</td></tr><tr><td align="center"><code>&lt;no option&gt;</code></td><td align="center">输出以上所有</td></tr></tbody></table><h2 id="执行样例"><a href="#执行样例" class="headerlink" title="执行样例"></a>执行样例</h2><h3 id="flag-lt-name-gt"><a href="#flag-lt-name-gt" class="headerlink" title="-flag &lt;name&gt;"></a><code>-flag &lt;name&gt;</code></h3><p>查询 CMSInitiatingOccupancyFraction 参数值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jinfo -flag CMSInitiatingOccupancyFraction 5511</span><br></pre></td></tr></table></figure><p><img src="/images/31-1.png"></p><h3 id="flag-lt-name-gt-1"><a href="#flag-lt-name-gt-1" class="headerlink" title="-flag [+/-]&lt;name&gt;"></a><code>-flag [+/-]&lt;name&gt;</code></h3><p>开启 / 关闭 PrintGC</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ jinfo -flag PrintGC 5511</span><br><span class="line">$ jinfo -flag +PrintGC 5511</span><br><span class="line">$ jinfo -flag PrintGC 5511</span><br><span class="line">$ jinfo -flag -PrintGC 5511</span><br><span class="line">$ jinfo -flag PrintGC 5511</span><br></pre></td></tr></table></figure><p><img src="/images/31-2.png"></p><h3 id="flag-lt-name-gt-lt-value-gt"><a href="#flag-lt-name-gt-lt-value-gt" class="headerlink" title="-flag &lt;name&gt;=&lt;value&gt;"></a><code>-flag &lt;name&gt;=&lt;value&gt;</code></h3><p>设置 HeapDumpPath</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ jinfo -flag HeapDumpPath 5511</span><br><span class="line">$ jinfo -flag HeapDumpPath&#x3D;&#x2F;root&#x2F;heapDump.hprof 5511</span><br><span class="line">$ jinfo -flag HeapDumpPath 5511</span><br><span class="line">$ jinfo -flag HeapDumpPath&#x3D; 5511</span><br><span class="line">$ jinfo -flag HeapDumpPath 5511</span><br></pre></td></tr></table></figure><p><img src="/images/31-3.png"></p><p>​但是不是每个参数都可以被动态修改的，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flag CMSInitiatingOccupancyFraction&#x3D;1 5511</span><br></pre></td></tr></table></figure><p><img src="/images/31-4.png"></p><h3 id="flags"><a href="#flags" class="headerlink" title="-flags"></a>-flags</h3><p>输出虚拟机参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jinfo -flags</span><br></pre></td></tr></table></figure><p><img src="/images/31-5.png"></p><h3 id="sysprops"><a href="#sysprops" class="headerlink" title="-sysprops"></a>-sysprops</h3><p>输出 Java 系统属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jinfo -sysprops 5511</span><br></pre></td></tr></table></figure><p><img src="/images/31-6.png"></p><h3 id="lt-no-option-gt"><a href="#lt-no-option-gt" class="headerlink" title="&lt;no option&gt;"></a><code>&lt;no option&gt;</code></h3><p>输出以上所有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jinfo 5511</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JDK 的 bin 目录下为 Java 开发人员提供了很多实用的小工具，很多场景下都会用到它们，比如：打包、部署、签名、调试、监控、运维等。本文介绍其中一款：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;jinfo (Configuration Info for Java)&lt;/stron</summary>
      
    
    
    
    <category term="JVM" scheme="http://yangsanity.me/categories/JVM/"/>
    
    
    <category term="JVM Tool" scheme="http://yangsanity.me/tags/JVM-Tool/"/>
    
  </entry>
  
  <entry>
    <title>jstat 基本命令</title>
    <link href="http://yangsanity.me/2021/04/02/jstat-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>http://yangsanity.me/2021/04/02/jstat-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</id>
    <published>2021-04-02T13:23:24.000Z</published>
    <updated>2022-05-07T02:09:59.750Z</updated>
    
    <content type="html"><![CDATA[<p>JDK 的 bin 目录下为 Java 开发人员提供了很多实用的小工具，很多场景下都会用到它们，比如：打包、部署、签名、调试、监控、运维等。本文介绍其中一款：</p><p><strong>jstat (JVM Statistics Monitoring Tool)</strong>: 虚拟机统计信息监视工具</p><p><em>详细信息可参考：<a href="https://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html">jstat doc</a></em></p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>用于监视虚拟机各种运行状态信息的命令行工具。可以显示本地或远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据。</p><h3 id="远程虚拟机进程"><a href="#远程虚拟机进程" class="headerlink" title="远程虚拟机进程"></a>远程虚拟机进程</h3><p>需要远程主机提供 RMI 支持，JDK 中提供了 jstatd 工具可以很方便地建立远程 RMI 服务器。</p><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>jstat [ option vmid [interval[s|ms] [count]] ]</p><h3 id="VMID-与-LVMID"><a href="#VMID-与-LVMID" class="headerlink" title="VMID 与 LVMID"></a>VMID 与 LVMID</h3><p>如果是本地虚拟机进程，VMID 与 LVMID 是一致的；如果是远程虚拟机进程，那 VMID 的格式应当是：</p><p>[protocol:][//]lvmid[@hostname[:port]/servername]</p><h3 id="interval-和-count"><a href="#interval-和-count" class="headerlink" title="interval 和 count"></a>interval 和 count</h3><p>interval: 查询间隔。如果没有显示指定，默认单位为 ms。</p><p>count: 次数</p><p>如果省略这 2 个参数，说明只查询一次。</p><p>假设需要每 250 毫秒查询一次进程 2764 垃圾收集状况，一共查询 20 次，那命令应当是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc 2764 250 20</span><br></pre></td></tr></table></figure><h3 id="option"><a href="#option" class="headerlink" title="option"></a>option</h3><p>代表用户希望查询的虚拟机信息，主要分为三类: <strong><em>类加载、垃圾收集、运行期编译状况</em></strong>。</p><p>可以通过如下命令查看所有选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -options</span><br></pre></td></tr></table></figure><p><img src="/images/30-1.png"></p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-class</td><td align="center">监视类加载、卸载数量、总空间以及类装载所耗费的时间</td></tr><tr><td align="center">-gc</td><td align="center">监视 Java 堆状况，包括 Eden 区、2 个 Survivor 区、老年代、永久代等的容量，已用空间、垃圾收集时间合计等信息</td></tr><tr><td align="center">-gccapacity</td><td align="center">监视内容与 -gc 基本相同，但输出主要关注 Java 堆各个区域使用到的最大、最小空间</td></tr><tr><td align="center">-gcutil</td><td align="center">监视内容与 -gc 基本相同，但输出主要关注已使用空间占总空间的百分比</td></tr><tr><td align="center">-gccause</td><td align="center">与 -gcutil 功能一样，但是会额外输出导致上一次垃圾收集产生的原因</td></tr><tr><td align="center">-gcnew</td><td align="center">监视新生代垃圾收集状况</td></tr><tr><td align="center">-gcnewcapacity</td><td align="center">监视内容与 -gcnew 基本相同，输出主要关注使用到的最大、最小空间</td></tr><tr><td align="center">-gcold</td><td align="center">监视老年代垃圾收集状况</td></tr><tr><td align="center">-gcoldcapacity</td><td align="center">监视内容与 -gcold 基本相同，输出主要关注使用到的最大、最小空间</td></tr><tr><td align="center">-gcpermcapacity(x)</td><td align="center">输出永久代使用到的最大、最小空间 (高版本已移除)</td></tr><tr><td align="center">-compiler</td><td align="center">输出即时编译器(JIT compiler，just-in-time compiler)编译过的方法、耗时等信息</td></tr><tr><td align="center">-printcompilation</td><td align="center">输出已经被即时编译的方法</td></tr><tr><td align="center">-gcmetacapacity</td><td align="center">输出 metaspace 的统计信息</td></tr></tbody></table><h2 id="执行样例"><a href="#执行样例" class="headerlink" title="执行样例"></a>执行样例</h2><p><em>（旧版本可能会有 P (Permanent): 永久代）</em></p><h3 id="class"><a href="#class" class="headerlink" title="-class"></a>-class</h3><p>监视类加载、卸载数量、总空间以及类装载所耗费的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -class 5511</span><br></pre></td></tr></table></figure><p><img src="/images/30-2.png"></p><p>Loaded: 加载 class 数量<br>Bytes: 加载占用空间<br>Unloaded: 卸载 class 数量<br>Bytes: 卸载占用空间<br>Time: 执行类加载和卸载操作总耗时</p><h3 id="gc"><a href="#gc" class="headerlink" title="-gc"></a>-gc</h3><p>监视 Java 堆状况，包括 Eden 区、2 个 Survivor 区、老年代、永久代等的容量，已用空间、垃圾收集时间合计等信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc 5511</span><br></pre></td></tr></table></figure><p><img src="/images/30-3.png"></p><p>S0C (Survivor0 Capacity)、S1C (Survivor1 Capacity): S0 / S1 总空间 (KB)<br>S0U (Survivor0 Utilization)、S1U (Survivor1 Utilization): S0 / S1 已使用空间 (KB)<br>EC (Eden Capacity): Eden 总空间 (KB)<br>EU (Eden Utilization): Eden 已使用空间 (KB)<br>OC (Old Capacity): 老年代总空间 (KB)<br>OU (Old Utilization): 老年代已使用空间 (KB)<br>MC (Metaspace Capacity): 元数据区总空间 (KB)<br>MU (Metaspace Utilization): 元数据区已使用空间 (KB)<br>CCSC (Compressed Class Space Capacity): 压缩类空间大小 (KB)<br>CCSU (Compressed Class Space Utilization): 压缩类空间已使用大小 (KB)<br>YGC (Young GC / Minor GC): Young GC 次数<br>YGCT (Young GC Time): Young GC 耗时<br>FGC (Full GC): Full GC 次数<br>FGCT (Full GC Time): Full GC 耗时<br>GCT (GC Time): GC 总耗时</p><h3 id="gccapacity"><a href="#gccapacity" class="headerlink" title="-gccapacity"></a>-gccapacity</h3><p>监视内容与 -gc 基本相同，但输出主要关注 Java 堆各个区域使用到的最大、最小空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gccapacity 5511</span><br></pre></td></tr></table></figure><p><img src="/images/30-4.png"></p><p>NGCMN (New Generation Capacity Min): 新生代最小容量 (KB)<br>NGCMX (New Generation Capacity Max): 新生代最大容量 (KB)<br>NGC (New Generation Capacity): 新生代总空间 (KB)<br>S0C (Survivor0 Capacity)、S1C (Survivor1 Capacity): S0 / S1 总空间 (KB)<br>EC (Eden Capacity): Eden 总空间 (KB)<br>OGCMN (Old Generation Capacity Min): 老年代最小容量 (KB)<br>OGCMX (Old Generation Capacity Max): 老年代最大容量 (KB)<br>OGC (Old Generation Capacity)、OC (Old Capacity): 老年代总空间 (KB)<br>MCMN (Metaspace Capacity Min): 元数据区最小容量 (KB)<br>MCMX (Metaspace Capacity Max): 元数据区最大容量 (KB)<br>MC (Metaspace Capacity): 元数据区总空间 (KB)<br>CCSMN (Compressed Class Space Min): 压缩类空间最小容量 (KB)<br>CCSMX (Compressed Class Space Max): 压缩类空间最大容量 (KB)<br>CCSC (Compressed Class Space Capacity): 压缩类空间大小 (KB)<br>YGC (Young GC / Minor GC): Young GC 次数<br>FGC (Full GC): Full GC 次数</p><h3 id="gcutil"><a href="#gcutil" class="headerlink" title="-gcutil"></a>-gcutil</h3><p>监视内容与 -gc 基本相同，但输出主要关注已使用空间占总空间的百分比。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcutil 5511</span><br></pre></td></tr></table></figure><p><img src="/images/30-5.png"></p><p>S0 (Survivor0)、S1 (Survivor1): S0 / S1 使用比例<br>E (Eden): Eden 使用比例<br>O (Old): 老年代使用比例<br>M (Metaspace): 元数据区使用比例<br>CCS (Compressed Class Space): 压缩类空间使用比例<br>YGC (Young GC / Minor GC): Young GC 次数<br>YGCT (Young GC Time): Young GC 耗时<br>FGC (Full GC): Full GC 次数<br>FGCT (Full GC Time): Full GC 耗时<br>GCT (GC Time): GC 总耗时</p><h3 id="gccause"><a href="#gccause" class="headerlink" title="-gccause"></a>-gccause</h3><p>与 -gcutil 功能一样，但是会额外输出导致上一次垃圾收集产生的原因。（输出结果比 -gcutil 多了 LGCC 和 GCC）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gccause 5511</span><br></pre></td></tr></table></figure><p><img src="/images/30-6.png"></p><p>S0 (Survivor0)、S1 (Survivor1): S0 / S1 使用比例<br>E (Eden): Eden 使用比例<br>O (Old): 老年代使用比例<br>M (Metaspace): 元数据区使用比例<br>CCS (Compressed Class Space): 压缩类空间使用比例<br>YGC (Young GC / Minor GC): Young GC 次数<br>YGCT (Young GC Time): Young GC 耗时<br>FGC (Full GC): Full GC 次数<br>FGCT (Full GC Time): Full GC 耗时<br>GCT (GC Time): GC 总耗时<br>LGCC (Last GC Cause): 上次 GC 原因<br>GCC (GC Cause): 本次 GC 原因</p><h3 id="gcnew"><a href="#gcnew" class="headerlink" title="-gcnew"></a>-gcnew</h3><p>监视新生代垃圾收集状况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcnew 5511</span><br></pre></td></tr></table></figure><p><img src="/images/30-7.png"></p><p>S0C (Survivor0 Capacity)、S1C (Survivor1 Capacity): S0 / S1 总空间 (KB)<br>S0U (Survivor0 Utilization)、S1U (Survivor1 Utilization): S0 / S1 已使用空间 (KB)<br>TT (Tenuring Threshold): 对象在新生代的存活次数<br>MTT (Max Tenuring Threshold): 对象在新生代存活的最大次数<br>DSS (Desired Survivor Size): 期望的幸存区大小 (KB)<br>EC (Eden Capacity): Eden 总空间 (KB)<br>EU (Eden Utilization): Eden 已使用空间 (KB)<br>YGC (Young GC / Minor GC): Young GC 次数<br>YGCT (Young GC Time): Young GC 耗时</p><h3 id="gcnewcapacity"><a href="#gcnewcapacity" class="headerlink" title="-gcnewcapacity"></a>-gcnewcapacity</h3><p>监视内容与 -gcnew 基本相同，输出主要关注使用到的最大、最小空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcnewcapacity 5511</span><br></pre></td></tr></table></figure><p><img src="/images/30-8.png"></p><p>NGCMN (New Generation Capacity Min): 新生代最小容量 (KB)<br>NGCMX (New Generation Capacity Max): 新生代最大容量 (KB)<br>NGC (New Generation Capacity): 新生代总空间 (KB)<br>S0CMX (Survivor0 Capacity Max): S0 最大容量 (KB)<br>S0C (Survivor0 Capacity): S0 总空间 (KB)<br>S1CMX (Survivor1 Capacity Max): S1 最大容量 (KB)<br>S1C (Survivor1 Capacity): S1 总空间 (KB)<br>ECMX (Eden Capacity Max): Eden 最大容量 (KB)<br>EC (Eden Capacity): Eden 总空间 (KB)<br>YGC (Young GC / Minor GC): Young GC 次数<br>FGC (Full GC): Full GC 次数</p><h3 id="gcold"><a href="#gcold" class="headerlink" title="-gcold"></a>-gcold</h3><p>监视老年代垃圾收集状况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcold 5511</span><br></pre></td></tr></table></figure><p><img src="/images/30-9.png"></p><p>MC (Metaspace Capacity): 元数据区总空间 (KB)<br>MU (Metaspace Utilization): 元数据区已使用空间 (KB)<br>CCSC (Compressed Class Space Capacity): 压缩类空间大小 (KB)<br>CCSU (Compressed Class Space Utilization): 压缩类空间已使用大小 (KB)<br>OC (Old Capacity): 老年代总空间 (KB)<br>OU (Old Utilization): 老年代已使用空间 (KB)<br>YGC (Young GC / Minor GC): Young GC 次数<br>FGC (Full GC): Full GC 次数<br>FGCT (Full GC Time): Full GC 耗时<br>GCT (GC Time): GC 总耗时</p><h3 id="gcoldcapacity"><a href="#gcoldcapacity" class="headerlink" title="-gcoldcapacity"></a>-gcoldcapacity</h3><p>监视内容与 -gcold 基本相同，输出主要关注使用到的最大、最小空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcoldcapacity 5511</span><br></pre></td></tr></table></figure><p><img src="/images/30-10.png"></p><p>OGCMN (Old Generation Capacity Min): 老年代最小容量 (KB)<br>OGCMX (Old Generation Capacity Max): 老年代最大容量 (KB)<br>OGC (Old Generation Capacity)、OC (Old Capacity): 老年代总空间 (KB)<br>OC (Old Capacity): 老年代总空间 (KB)<br>YGC (Young GC / Minor GC): Young GC 次数<br>FGC (Full GC): Full GC 次数<br>FGCT (Full GC Time): Full GC 耗时<br>GCT (GC Time): GC 总耗时</p><h3 id="gcpermcapacity-x"><a href="#gcpermcapacity-x" class="headerlink" title="-gcpermcapacity (x)"></a>-gcpermcapacity (x)</h3><p>输出永久代使用到的最大、最小空间。(高版本已移除)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcpermcapacity 5511</span><br></pre></td></tr></table></figure><p><em>会提示：Unknown option: -gcpermcapacity</em></p><h3 id="compiler"><a href="#compiler" class="headerlink" title="-compiler"></a>-compiler</h3><p>输出即时编译器(JIT compiler，just-in-time compiler)编译过的方法、耗时等信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -compiler 5511</span><br></pre></td></tr></table></figure><p><img src="/images/30-11.png"></p><p>Compiled: 编译任务数<br>Failed: 失败的编译任务数<br>Invalid: 无效的编译任务数<br>Time: 编译花费时间<br>FailedType: 上次编译失败的编译类型<br>FailedMethod: 上次编译失败的类名和方法</p><h3 id="printcompilation"><a href="#printcompilation" class="headerlink" title="-printcompilation"></a>-printcompilation</h3><p>输出已经被即时编译的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -printcompilation 5511</span><br></pre></td></tr></table></figure><p><img src="/images/30-12.png"></p><p>Compiled: 最近编译方法的数量<br>Size: 最近编译方法的字节码数量<br>Type: 最近编译方法的编译类型<br>Method: 标识最近编译方法的类名和方法名。这两个字段的格式与 HotSpot - XX:+PrintComplation 选项一致</p><h3 id="gcmetacapacity"><a href="#gcmetacapacity" class="headerlink" title="-gcmetacapacity"></a>-gcmetacapacity</h3><p>输出 metaspace 的统计信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcmetacapacity 5511</span><br></pre></td></tr></table></figure><p><img src="/images/30-13.png"></p><p>MCMN (Metaspace Capacity Min): 元数据区最小容量 (KB)<br>MCMX (Metaspace Capacity Max): 元数据区最大容量 (KB)<br>MC (Metaspace Capacity): 元数据区总空间 (KB)<br>CCSMN (Compressed Class Space Min): 压缩类空间最小容量 (KB)<br>CCSMX (Compressed Class Space Max): 压缩类空间最大容量 (KB)<br>CCSC (Compressed Class Space Capacity): 压缩类空间大小 (KB)<br>YGC (Young GC / Minor GC): Young GC 次数<br>FGC (Full GC): Full GC 次数<br>FGCT (Full GC Time): Full GC 耗时<br>GCT (GC Time): GC 总耗时</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JDK 的 bin 目录下为 Java 开发人员提供了很多实用的小工具，很多场景下都会用到它们，比如：打包、部署、签名、调试、监控、运维等。本文介绍其中一款：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;jstat (JVM Statistics Monitoring Tool)&lt;/st</summary>
      
    
    
    
    <category term="JVM" scheme="http://yangsanity.me/categories/JVM/"/>
    
    
    <category term="JVM Tool" scheme="http://yangsanity.me/tags/JVM-Tool/"/>
    
  </entry>
  
  <entry>
    <title>jps 基本命令</title>
    <link href="http://yangsanity.me/2021/04/01/jps-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>http://yangsanity.me/2021/04/01/jps-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</id>
    <published>2021-04-01T01:00:26.000Z</published>
    <updated>2022-05-07T02:09:59.750Z</updated>
    
    <content type="html"><![CDATA[<p>JDK 的 bin 目录下为 Java 开发人员提供了很多实用的小工具，很多场景下都会用到它们，比如：打包、部署、签名、调试、监控、运维等。本文介绍其中一款：</p><p><strong>jps (JVM Process Status Tool)</strong>: 虚拟机进程状况工具</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>比较单一，列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main() 函数所在的类）名称以及这些进程的本地虚拟机唯一 ID（LVMID）。</p><h3 id="LVMID-和-PID"><a href="#LVMID-和-PID" class="headerlink" title="LVMID 和 PID"></a>LVMID 和 PID</h3><p>LVMID (Local Virtual Machine Identifier): 本地虚拟机进程的唯一 ID</p><p>PID (Process Identifier): 操作系统的进程 ID</p><p>对于本地虚拟机进程来说，LVMID 与 PID 是一致的。</p><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [ options ] [ hostid ]</span><br></pre></td></tr></table></figure><h3 id="options"><a href="#options" class="headerlink" title="options"></a>options</h3><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-q</td><td align="center">只输出 LVMID，省略主类的名称</td></tr><tr><td align="center">-m</td><td align="center">输出虚拟机进程启动时传递给主类 main() 函数的参数</td></tr><tr><td align="center">-l</td><td align="center">输出主类的全名，如果进程执行的是 JAR 包，则输出 JAR 路径</td></tr><tr><td align="center">-v</td><td align="center">输出虚拟机进程启动时的 JVM 参数</td></tr></tbody></table><h3 id="hostid"><a href="#hostid" class="headerlink" title="hostid"></a>hostid</h3><p>jps 还可以通过 RMI 协议查询开启了 RMI 服务的远程虚拟机进程状态，参数 hostid 为 RMI 注册表中注册的主机名。</p><h2 id="执行样例"><a href="#执行样例" class="headerlink" title="执行样例"></a>执行样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jps -l</span><br></pre></td></tr></table></figure><p><img src="/images/29-1.png"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JDK 的 bin 目录下为 Java 开发人员提供了很多实用的小工具，很多场景下都会用到它们，比如：打包、部署、签名、调试、监控、运维等。本文介绍其中一款：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;jps (JVM Process Status Tool)&lt;/strong&gt;: 虚拟</summary>
      
    
    
    
    <category term="JVM" scheme="http://yangsanity.me/categories/JVM/"/>
    
    
    <category term="JVM Tool" scheme="http://yangsanity.me/tags/JVM-Tool/"/>
    
  </entry>
  
  <entry>
    <title>Flink JobManager 内存模型</title>
    <link href="http://yangsanity.me/2021/03/31/Flink-JobManager-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yangsanity.me/2021/03/31/Flink-JobManager-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-03-31T01:00:00.000Z</published>
    <updated>2022-05-07T02:09:59.749Z</updated>
    
    <content type="html"><![CDATA[<p>本文适用于 1.11 及以上版本，整理自 <a href="https://ci.apache.org/projects/flink/flink-docs-master/zh/docs/deployment/memory/mem_setup_jobmanager/">Flink 官网-配置 JobManager 内存</a>。</p><h1 id="非本地执行"><a href="#非本地执行" class="headerlink" title="非本地执行"></a>非本地执行</h1><h2 id="内存模型-Memory-Model"><a href="#内存模型-Memory-Model" class="headerlink" title="内存模型(Memory Model)"></a>内存模型(Memory Model)</h2><p><img src="https://ci.apache.org/projects/flink/flink-docs-master/fig/process_mem_model.svg" alt="process_mem_model"></p><h2 id="配置选项-Configuration-Options"><a href="#配置选项-Configuration-Options" class="headerlink" title="配置选项(Configuration Options)"></a>配置选项(Configuration Options)</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><img src="/images/28-1.png" alt="Overview"></p><h3 id="进程总内存-Total-Process-Memory"><a href="#进程总内存-Total-Process-Memory" class="headerlink" title="进程总内存(Total Process Memory)"></a>进程总内存(Total Process Memory)</h3><p><strong><em>jobmanager.memory.process.size = (none)</em></strong></p><p><em>对于容器化部署模式（Containerized Deployment），这相当于申请的容器（Container）大小。</em></p><h4 id="Flink-总内存-Total-Flink-Memory"><a href="#Flink-总内存-Total-Flink-Memory" class="headerlink" title="Flink 总内存(Total Flink Memory)"></a>Flink 总内存(Total Flink Memory)</h4><p><strong><em>jobmanager.memory.flink.size = (none)</em></strong></p><h5 id="JVM-Heap"><a href="#JVM-Heap" class="headerlink" title="JVM Heap"></a>JVM Heap</h5><p><em>JobManager 的 JVM 堆内存。</em></p><p><strong><em>jobmanager.memory.heap.size = (none)</em></strong></p><h5 id="Off-Heap-Memory"><a href="#Off-Heap-Memory" class="headerlink" title="Off-Heap Memory"></a>Off-Heap Memory</h5><p><em>JobManager 的堆外内存。</em></p><p><strong><em>jobmanager.memory.off-heap.size = 128 mb</em></strong></p><h4 id="JVM-元空间-JVM-Metaspace-Off-Heap"><a href="#JVM-元空间-JVM-Metaspace-Off-Heap" class="headerlink" title="JVM 元空间(JVM Metaspace)(Off-Heap)"></a>JVM 元空间(JVM Metaspace)(<em>Off-Heap</em>)</h4><p><em>Flink JVM 进程的 Metaspace。</em></p><p><strong><em>jobmanager.memory.jvm-metaspace.size = 256 mb</em></strong></p><h4 id="JVM-开销-JVM-Overhead-Off-Heap"><a href="#JVM-开销-JVM-Overhead-Off-Heap" class="headerlink" title="JVM 开销(JVM Overhead)(Off-Heap)"></a>JVM 开销(JVM Overhead)(<em>Off-Heap</em>)</h4><p><em>用于其他 JVM 开销的本地内存，例如栈空间、垃圾回收空间等。</em></p><p><strong><em>jobmanager.memory.jvm-overhead.(min/max/fraction) = (192 mb/1 gb/0.1)</em></strong></p><h2 id="JVM-参数-JVM-Parameters"><a href="#JVM-参数-JVM-Parameters" class="headerlink" title="JVM 参数(JVM Parameters)"></a>JVM 参数(JVM Parameters)</h2><p>Flink 进程启动时，会根据配置的和自动推导出的各内存部分大小，也可以显式地设置以下 JVM 参数：</p><table><thead><tr><th align="center">JVM 参数</th><th align="center">JobManager 取值</th></tr></thead><tbody><tr><td align="center">-Xmx 和 -Xms</td><td align="center">JVM 堆内存(JVM Heap)</td></tr><tr><td align="center">-XX:MaxDirectMemorySize</td><td align="center">堆外内存(Off-Heap Memory)</td></tr><tr><td align="center">-XX:MaxMetaspaceSize</td><td align="center">JVM 元空间(JVM Metaspace)</td></tr></tbody></table><h2 id="建议-recommend"><a href="#建议-recommend" class="headerlink" title="建议(recommend)"></a>建议(recommend)</h2><ul><li><p>如果已经明确设置了 <strong><em>JVM 堆内存(jobmanager.memory.heap.size)</em></strong>，建议不要再设置 <strong><em>进程总内存(jobmanager.memory.process.size)</em></strong> 或 <strong><em>Flink 总内存(jobmanager.memory.flink.size)</em></strong>，否则可能会造成内存配置冲突。</p></li><li><p>如果遇到 JobManager 进程抛出 “OutOfMemoryError: Direct buffer memory” 的异常，可以尝试调大 <strong><em>堆外内存(jobmanager.memory.off-heap.size)</em></strong> 配置。</p></li><li><p>如果同时配置了 <strong><em>Flink 总内存(jobmanager.memory.flink.size)</em></strong> 和 <strong><em>JVM 堆内存(jobmanager.memory.heap.size)</em></strong>，且没有配置 <strong><em>堆外内存(jobmanager.memory.off-heap.size)</em></strong>，那么 <em>堆外内存的大小 = Flink 总内存 - JVM 堆内存</em>。 这种情况下，<em>堆外内存</em> 的默认大小将不会生效。</p></li></ul><h1 id="本地执行-Local-Execution"><a href="#本地执行-Local-Execution" class="headerlink" title="本地执行(Local Execution)"></a>本地执行(Local Execution)</h1><p>本地执行(Local Execution) 是指将 Flink 作为一个单独的 Java 程序运行在电脑本地而非创建一个集群（例如在 IDE 中）。</p><p>本地执行模式下不需要为 JobManager 进行内存配置，配置参数将不会生效。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文适用于 1.11 及以上版本，整理自 &lt;a href=&quot;https://ci.apache.org/projects/flink/flink-docs-master/zh/docs/deployment/memory/mem_setup_jobmanager/&quot;&gt;Fli</summary>
      
    
    
    
    <category term="flink" scheme="http://yangsanity.me/categories/flink/"/>
    
    
    <category term="flink memory" scheme="http://yangsanity.me/tags/flink-memory/"/>
    
  </entry>
  
  <entry>
    <title>Flink TaskManager 内存模型</title>
    <link href="http://yangsanity.me/2021/03/30/Flink-TaskManager-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yangsanity.me/2021/03/30/Flink-TaskManager-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-03-30T14:57:03.000Z</published>
    <updated>2022-05-07T02:09:59.749Z</updated>
    
    <content type="html"><![CDATA[<p>本文适用于 1.10 及以上版本，整理自 <a href="https://ci.apache.org/projects/flink/flink-docs-master/zh/docs/deployment/memory/mem_setup_tm/">Flink 官网-配置 TaskManager 内存</a>。</p><h1 id="非本地执行"><a href="#非本地执行" class="headerlink" title="非本地执行"></a>非本地执行</h1><h2 id="内存模型-Memory-Model"><a href="#内存模型-Memory-Model" class="headerlink" title="内存模型(Memory Model)"></a>内存模型(Memory Model)</h2><h3 id="Simple-Memory-Model"><a href="#Simple-Memory-Model" class="headerlink" title="Simple Memory Model"></a>Simple Memory Model</h3><p><img src="https://ci.apache.org/projects/flink/flink-docs-master/fig/simple_mem_model.svg" alt="simple_mem_model"></p><h3 id="Detailed-Memory-Model"><a href="#Detailed-Memory-Model" class="headerlink" title="Detailed Memory Model"></a>Detailed Memory Model</h3><p><img src="https://ci.apache.org/projects/flink/flink-docs-master/fig/detailed-mem-model.svg" alt="detailed-mem-model"></p><h2 id="配置选项-Configuration-Options"><a href="#配置选项-Configuration-Options" class="headerlink" title="配置选项(Configuration Options)"></a>配置选项(Configuration Options)</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><img src="/images/27-1.png" alt="Overview"></p><h3 id="进程总内存-Total-Process-Memory"><a href="#进程总内存-Total-Process-Memory" class="headerlink" title="进程总内存(Total Process Memory)"></a>进程总内存(Total Process Memory)</h3><p><strong><em>taskmanager.memory.process.size = (none)</em></strong></p><p><em>对于容器化部署模式（Containerized Deployment），这相当于申请的容器（Container）大小。</em></p><h4 id="Flink-总内存-Total-Flink-Memory"><a href="#Flink-总内存-Total-Flink-Memory" class="headerlink" title="Flink 总内存(Total Flink Memory)"></a>Flink 总内存(Total Flink Memory)</h4><p><strong><em>taskmanager.memory.flink.size = (none)</em></strong></p><h5 id="JVM-Heap"><a href="#JVM-Heap" class="headerlink" title="JVM Heap"></a>JVM Heap</h5><ul><li><p>框架堆内存(Framework Heap)</p><p><em>Flink 框架使用的（内部数据结构及操作使用的）堆内存。即 TaskManager 本身所占用的堆上内存，不计入 Slot 资源中。</em></p><p><strong><em>taskmanager.memory.framework.heap.size = 128 mb</em></strong></p></li><li><p>任务堆内存 / 任务（算子）堆内存(Task Heap / Task (Operator) Heap Memory)</p><p><em>Flink 应用的算子及用户代码执行所使用的堆内存。</em></p><p><strong><em>taskmanager.memory.task.heap.size = (none)</em></strong></p></li></ul><h5 id="Off-Heap-Memory"><a href="#Off-Heap-Memory" class="headerlink" title="Off-Heap Memory"></a>Off-Heap Memory</h5><ul><li><p>托管内存(Managed Memory)</p><p><em>由 Flink 分配和管理的用于排序、哈希表、缓存中间结果及 RocksDB State Backend 的本地内存。</em></p><p><strong><em>taskmanager.memory.managed.(size/fraction) = (none/0.4)</em></strong></p><p>当同时指定二者时，会优先采用 size 指定的大小。若二者均未指定，会根据默认占比进行计算。</p></li><li><p>直接内存(Direct Memory)</p><ul><li><p>框架堆外内存(Framework Off-Heap)</p><p><em>Flink 框架使用的（内部数据结构及操作使用的）堆外内存。即 TaskManager 本身所占用的堆外内存，不计入 Slot 资源中。</em></p><p><strong><em>taskmanager.memory.framework.off-heap.size = 128 mb</em></strong></p></li><li><p>任务堆外内存(Task Off-Heap)</p><p><em>Flink 应用的算子及用户代码执行所使用的堆外内存。</em></p><p><strong><em>taskmanager.memory.task.off-heap.size = 0 bytes</em></strong></p></li><li><p>网络内存(Network)</p><p><em>用于任务（task）之间数据传输的直接内存（例如网络传输缓冲区）。</em></p><p><strong><em>taskmanager.memory.network.(min/max/fraction) = (64 mb/1 gb/0.1)</em></strong></p></li></ul></li></ul><h4 id="JVM-Specific-Memory-Off-Heap"><a href="#JVM-Specific-Memory-Off-Heap" class="headerlink" title="JVM Specific Memory(Off-Heap)"></a>JVM Specific Memory(<em>Off-Heap</em>)</h4><p><em>运行 Flink 的 JVM 使用的内存。</em></p><h5 id="JVM-元空间-JVM-Metaspace"><a href="#JVM-元空间-JVM-Metaspace" class="headerlink" title="JVM 元空间(JVM Metaspace)"></a>JVM 元空间(JVM Metaspace)</h5><p><em>Flink JVM 进程的 Metaspace。</em></p><p><strong><em>taskmanager.memory.jvm-metaspace.size = 256 mb</em></strong></p><h5 id="JVM-开销-JVM-Overhead"><a href="#JVM-开销-JVM-Overhead" class="headerlink" title="JVM 开销(JVM Overhead)"></a>JVM 开销(JVM Overhead)</h5><p><em>用于其他 JVM 开销的本地内存，例如栈空间、垃圾回收空间等。</em></p><p><strong><em>taskmanager.memory.jvm-overhead.(min/max/fraction) = (192 mb/1 gb/0.1)</em></strong></p><h2 id="JVM-参数-JVM-Parameters"><a href="#JVM-参数-JVM-Parameters" class="headerlink" title="JVM 参数(JVM Parameters)"></a>JVM 参数(JVM Parameters)</h2><p>Flink 进程启动时，会根据配置的和自动推导出的各内存部分大小，也可以显式地设置以下 JVM 参数：</p><table><thead><tr><th align="center">JVM 参数</th><th align="center">TaskManager 取值</th></tr></thead><tbody><tr><td align="center">-Xmx 和 -Xms</td><td align="center">框架堆内存(Framework Heap) + 任务堆内存(Task Heap)</td></tr><tr><td align="center">-XX:MaxDirectMemorySize</td><td align="center">框架堆外内存(Framework Off-Heap) + 任务堆外内存(Task Off-Heap) + 网络内存(Network)</td></tr><tr><td align="center">-XX:MaxMetaspaceSize</td><td align="center">JVM 元空间(JVM Metaspace)</td></tr></tbody></table><h2 id="建议-recommend"><a href="#建议-recommend" class="headerlink" title="建议(recommend)"></a>建议(recommend)</h2><ul><li><p>不建议同时设置 <strong><em>进程总内存(taskmanager.memory.process.size)</em></strong> 和 <strong><em>Flink 总内存(taskmanager.memory.flink.size)</em></strong>。 这可能会造成内存配置冲突，从而导致部署失败。</p></li><li><p>如果已经明确设置了 <strong><em>任务堆内存(taskmanager.memory.task.heap.size)</em></strong> 和 <strong><em>托管内存(taskmanager.memory.managed.(size/fraction))</em></strong>，建议不要再设置 <strong><em>进程总内存(taskmanager.memory.process.size)</em></strong> 或 <strong><em>Flink 总内存(taskmanager.memory.flink.size)</em></strong>，否则可能会造成内存配置冲突。</p></li><li><p><strong><em>框架堆外内存(taskmanager.memory.framework.off-heap.size)</em></strong> 是一个进阶配置，建议仅在确定 Flink 框架需要更多的内存时调整该配置。</p></li><li><p>通常情况下，不建议对 <strong><em>框架堆内存(taskmanager.memory.framework.heap.size)</em></strong> 和 <strong><em>框架堆外内存(taskmanager.memory.framework.off-heap.size)</em></strong> 进行调整。 除非你非常肯定 Flink 的内部数据结构及操作需要更多的内存。</p></li><li><p>Flink 会负责管理 <strong><em>网络内存(taskmanager.memory.network.(min/max/fraction))</em></strong>，保证其实际用量不会超过配置大小。 因此，调整网络内存的大小不会对其他堆外内存有实质上的影响。</p></li></ul><h1 id="本地执行-Local-Execution"><a href="#本地执行-Local-Execution" class="headerlink" title="本地执行(Local Execution)"></a>本地执行(Local Execution)</h1><p>本地执行(Local Execution) 是指将 Flink 作为一个单独的 Java 程序运行在电脑本地而非创建一个集群（例如在 IDE 中）。</p><p>本地执行​时，只有下列配置会生效，其他配置参数不会起到任何效果：</p><table><thead><tr><th align="center">组成部分</th><th align="center">配置参数</th><th align="center">本地执行时的默认值</th></tr></thead><tbody><tr><td align="center">任务堆内存(Task Heap)</td><td align="center">taskmanager.memory.task.heap.size</td><td align="center">无穷大(Long.MAX_VALUE)</td></tr><tr><td align="center">任务堆外内存(Task Off-Heap)</td><td align="center">taskmanager.memory.task.off-heap.size</td><td align="center">无穷大(Long.MAX_VALUE)</td></tr><tr><td align="center">托管内存(Managed Memory)</td><td align="center">taskmanager.memory.managed.size</td><td align="center">128Mb</td></tr><tr><td align="center">网络内存(Network)</td><td align="center">taskmanager.memory.network.(min/max)</td><td align="center">64Mb</td></tr></tbody></table><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><ul><li><p>本地执行模式下，任务堆内存的大小与实际的堆空间大小无关。</p></li><li><p>本地执行模式下，JVM 堆空间的实际大小不受 Flink 掌控，而是取决于本地执行进程是如何启动的。如果希望控制 JVM 的堆空间大小，可以在启动进程时明确地指定相关的 JVM 参数，即 -Xmx 和 -Xms。</p></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文适用于 1.10 及以上版本，整理自 &lt;a href=&quot;https://ci.apache.org/projects/flink/flink-docs-master/zh/docs/deployment/memory/mem_setup_tm/&quot;&gt;Flink 官网-配置</summary>
      
    
    
    
    <category term="flink" scheme="http://yangsanity.me/categories/flink/"/>
    
    
    <category term="flink memory" scheme="http://yangsanity.me/tags/flink-memory/"/>
    
  </entry>
  
</feed>
